{{- if and .Service.Features.Database (eq .Service.Database.Type "postgresql") -}}
// Copyright Â© {{year}} {{.Author}}
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Package db provides PostgreSQL database connectivity for {{.Service.Name}}.
package db

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"go.uber.org/zap"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"

	"{{.Service.ModulePath}}/internal/{{.Package.Name}}/model"
)

// PostgreSQLDatabase represents a PostgreSQL database connection.
type PostgreSQLDatabase struct {
	db     *gorm.DB
	sqlDB  *sql.DB
	config *PostgreSQLConfig
	logger *zap.Logger
}

// NewPostgreSQLDatabase creates a new PostgreSQL database connection.
func NewPostgreSQLDatabase(config *PostgreSQLConfig, logger *zap.Logger) (*PostgreSQLDatabase, error) {
	if err := config.Validate(); err != nil {
		return nil, fmt.Errorf("invalid PostgreSQL configuration: %w", err)
	}

	// Configure GORM logger
	var gormLogger logger.Interface
	if config.EnableLogging {
		logLevel := logger.Info
		if config.LogStatements {
			logLevel = logger.Info
		} else {
			logLevel = logger.Warn
		}

		gormLogger = logger.New(
			NewGormLoggerWriter(logger),
			logger.Config{
				SlowThreshold: config.SlowQueryTime,
				LogLevel:      logLevel,
				Colorful:      false,
			},
		)
	} else {
		gormLogger = logger.Default.LogMode(logger.Silent)
	}

	// Create GORM configuration
	gormConfig := &gorm.Config{
		Logger:                                   gormLogger,
		DisableForeignKeyConstraintWhenMigrating: false,
		SkipDefaultTransaction:                   false,
		PrepareStmt:                              true,
		NamingStrategy: &gorm.NamingStrategy{
			TablePrefix:   "",
			SingularTable: false,
		},
	}

	// Open database connection
	db, err := gorm.Open(postgres.Open(config.DSN()), gormConfig)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to PostgreSQL database: %w", err)
	}

	// Get underlying sql.DB
	sqlDB, err := db.DB()
	if err != nil {
		return nil, fmt.Errorf("failed to get sql.DB from GORM: %w", err)
	}

	// Configure connection pool
	sqlDB.SetMaxIdleConns(config.MaxIdleConns)
	sqlDB.SetMaxOpenConns(config.MaxOpenConns)
	sqlDB.SetConnMaxLifetime(config.ConnMaxLifetime)
	sqlDB.SetConnMaxIdleTime(config.ConnMaxIdleTime)

	postgresDB := &PostgreSQLDatabase{
		db:     db,
		sqlDB:  sqlDB,
		config: config,
		logger: logger,
	}

	// Test connection
	if err := postgresDB.Ping(context.Background()); err != nil {
		return nil, fmt.Errorf("failed to ping PostgreSQL database: %w", err)
	}

	// Set schema if specified
	if config.Schema != "" && config.Schema != "public" {
		if err := postgresDB.setSearchPath(config.Schema); err != nil {
			return nil, fmt.Errorf("failed to set search path: %w", err)
		}
	}

	logger.Info("Successfully connected to PostgreSQL database",
		zap.String("host", config.Host),
		zap.Int("port", config.Port),
		zap.String("database", config.Database),
		zap.String("schema", config.Schema),
	)

	return postgresDB, nil
}

// DB returns the underlying GORM database instance.
func (d *PostgreSQLDatabase) DB() *gorm.DB {
	return d.db
}

// SqlDB returns the underlying sql.DB instance.
func (d *PostgreSQLDatabase) SqlDB() *sql.DB {
	return d.sqlDB
}

// Ping checks the database connection.
func (d *PostgreSQLDatabase) Ping(ctx context.Context) error {
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	return d.sqlDB.PingContext(ctx)
}

// HealthCheck performs a comprehensive database health check.
func (d *PostgreSQLDatabase) HealthCheck(ctx context.Context) error {
	// Check connection
	if err := d.Ping(ctx); err != nil {
		return fmt.Errorf("database ping failed: %w", err)
	}

	// Check if we can execute a simple query
	var version string
	if err := d.db.WithContext(ctx).Raw("SELECT version()").Scan(&version).Error; err != nil {
		return fmt.Errorf("failed to execute test query: %w", err)
	}

	// Check schema access
	var schemaExists bool
	if err := d.db.WithContext(ctx).Raw(
		"SELECT EXISTS(SELECT 1 FROM information_schema.schemata WHERE schema_name = ?)",
		d.config.Schema,
	).Scan(&schemaExists).Error; err != nil {
		return fmt.Errorf("failed to check schema existence: %w", err)
	}

	if !schemaExists {
		return fmt.Errorf("schema '%s' does not exist", d.config.Schema)
	}

	d.logger.Debug("Database health check passed",
		zap.String("postgres_version", version),
		zap.String("schema", d.config.Schema),
	)

	return nil
}

// setSearchPath sets the PostgreSQL search path.
func (d *PostgreSQLDatabase) setSearchPath(schema string) error {
	sql := fmt.Sprintf("SET search_path TO %s", schema)
	if err := d.db.Exec(sql).Error; err != nil {
		return fmt.Errorf("failed to set search path to '%s': %w", schema, err)
	}
	return nil
}

// CreateSchema creates a new schema if it doesn't exist.
func (d *PostgreSQLDatabase) CreateSchema(ctx context.Context, schema string) error {
	sql := fmt.Sprintf("CREATE SCHEMA IF NOT EXISTS %s", schema)
	if err := d.db.WithContext(ctx).Exec(sql).Error; err != nil {
		return fmt.Errorf("failed to create schema '%s': %w", schema, err)
	}

	d.logger.Info("Schema created or already exists", zap.String("schema", schema))
	return nil
}

// Migrate runs database migrations for all models.
func (d *PostgreSQLDatabase) Migrate() error {
	// Create schema if it doesn't exist
	if d.config.Schema != "" && d.config.Schema != "public" {
		if err := d.CreateSchema(context.Background(), d.config.Schema); err != nil {
			return fmt.Errorf("failed to create schema: %w", err)
		}
	}

	// Auto-migrate models
	if err := d.db.AutoMigrate(
		&model.{{.Service.Name | pascalCase}}{},
		// Add other models here
	); err != nil {
		return fmt.Errorf("failed to auto-migrate models: %w", err)
	}

	d.logger.Info("Database migration completed successfully")
	return nil
}

// Transaction executes a function within a database transaction.
func (d *PostgreSQLDatabase) Transaction(fn func(*gorm.DB) error) error {
	return d.db.Transaction(fn)
}

// TransactionWithContext executes a function within a database transaction with context.
func (d *PostgreSQLDatabase) TransactionWithContext(ctx context.Context, fn func(*gorm.DB) error) error {
	return d.db.WithContext(ctx).Transaction(fn)
}

// WithContext returns a new database instance with context.
func (d *PostgreSQLDatabase) WithContext(ctx context.Context) *gorm.DB {
	return d.db.WithContext(ctx)
}

// Stats returns database connection statistics.
func (d *PostgreSQLDatabase) Stats() sql.DBStats {
	return d.sqlDB.Stats()
}

// Close closes the database connection.
func (d *PostgreSQLDatabase) Close() error {
	if d.sqlDB != nil {
		if err := d.sqlDB.Close(); err != nil {
			return fmt.Errorf("failed to close PostgreSQL database connection: %w", err)
		}
		d.logger.Info("PostgreSQL database connection closed successfully")
	}
	return nil
}

// BeginTx starts a transaction with the given options.
func (d *PostgreSQLDatabase) BeginTx(ctx context.Context, opts *sql.TxOptions) (*gorm.DB, error) {
	tx := d.db.WithContext(ctx).Begin(opts)
	if tx.Error != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", tx.Error)
	}
	return tx, nil
}

// ExecuteInBatches executes a function in batches for large datasets.
func (d *PostgreSQLDatabase) ExecuteInBatches(ctx context.Context, batchSize int, fn func(*gorm.DB, int) error) error {
	batch := 0
	for {
		tx := d.db.WithContext(ctx)
		if err := fn(tx, batch); err != nil {
			return fmt.Errorf("batch %d failed: %w", batch, err)
		}
		batch++
		// Break condition should be implemented in the function
		// This is just a skeleton
		break
	}
	return nil
}

// EnableExtension enables a PostgreSQL extension.
func (d *PostgreSQLDatabase) EnableExtension(ctx context.Context, extension string) error {
	sql := fmt.Sprintf("CREATE EXTENSION IF NOT EXISTS %s", extension)
	if err := d.db.WithContext(ctx).Exec(sql).Error; err != nil {
		return fmt.Errorf("failed to enable extension '%s': %w", extension, err)
	}

	d.logger.Info("Extension enabled", zap.String("extension", extension))
	return nil
}

// GormLoggerWriter is a custom writer for GORM logger that uses zap.
type GormLoggerWriter struct {
	logger *zap.Logger
}

// NewGormLoggerWriter creates a new GORM logger writer.
func NewGormLoggerWriter(logger *zap.Logger) *GormLoggerWriter {
	return &GormLoggerWriter{logger: logger}
}

// Printf implements the writer interface for GORM logger.
func (w *GormLoggerWriter) Printf(format string, args ...interface{}) {
	w.logger.Debug(fmt.Sprintf(format, args...))
}
{{- end -}}