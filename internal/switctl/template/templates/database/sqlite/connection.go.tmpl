{{- if and .Service.Features.Database (eq .Service.Database.Type "sqlite") -}}
// Copyright Â© {{year}} {{.Author}}
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Package db provides SQLite database connectivity for {{.Service.Name}}.
package db

import (
	"context"
	"database/sql"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"go.uber.org/zap"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"

	"{{.Service.ModulePath}}/internal/{{.Package.Name}}/model"
)

// SQLiteDatabase represents a SQLite database connection.
type SQLiteDatabase struct {
	db     *gorm.DB
	sqlDB  *sql.DB
	config *SQLiteConfig
	logger *zap.Logger
}

// NewSQLiteDatabase creates a new SQLite database connection.
func NewSQLiteDatabase(config *SQLiteConfig, logger *zap.Logger) (*SQLiteDatabase, error) {
	if err := config.Validate(); err != nil {
		return nil, fmt.Errorf("invalid SQLite configuration: %w", err)
	}

	// Create directory for database file if needed
	if !config.InMemory {
		dir := filepath.Dir(config.DatabasePath)
		if dir != "." && dir != "" {
			if err := os.MkdirAll(dir, 0755); err != nil {
				return nil, fmt.Errorf("failed to create database directory: %w", err)
			}
		}
	}

	// Configure GORM logger
	var gormLogger logger.Interface
	if config.EnableLogging {
		gormLogger = logger.New(
			NewGormLoggerWriter(logger),
			logger.Config{
				SlowThreshold: config.SlowQueryTime,
				LogLevel:      logger.Info,
				Colorful:      false,
			},
		)
	} else {
		gormLogger = logger.Default.LogMode(logger.Silent)
	}

	// Create GORM configuration
	gormConfig := &gorm.Config{
		Logger:                                   gormLogger,
		DisableForeignKeyConstraintWhenMigrating: !config.ForeignKeys,
		SkipDefaultTransaction:                   false,
		PrepareStmt:                              true,
	}

	// Open database connection
	db, err := gorm.Open(sqlite.Open(config.DSN()), gormConfig)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to SQLite database: %w", err)
	}

	// Get underlying sql.DB
	sqlDB, err := db.DB()
	if err != nil {
		return nil, fmt.Errorf("failed to get sql.DB from GORM: %w", err)
	}

	// Configure connection pool
	sqlDB.SetMaxIdleConns(config.MaxIdleConns)
	sqlDB.SetMaxOpenConns(config.MaxOpenConns)
	sqlDB.SetConnMaxLifetime(config.ConnMaxLifetime)
	sqlDB.SetConnMaxIdleTime(config.ConnMaxIdleTime)

	sqliteDB := &SQLiteDatabase{
		db:     db,
		sqlDB:  sqlDB,
		config: config,
		logger: logger,
	}

	// Apply SQLite-specific settings
	if err := sqliteDB.applySettings(); err != nil {
		return nil, fmt.Errorf("failed to apply SQLite settings: %w", err)
	}

	// Test connection
	if err := sqliteDB.Ping(context.Background()); err != nil {
		return nil, fmt.Errorf("failed to ping SQLite database: %w", err)
	}

	logger.Info("Successfully connected to SQLite database",
		zap.String("database_path", config.DatabasePath),
		zap.Bool("in_memory", config.InMemory),
		zap.String("journal_mode", config.JournalMode),
	)

	return sqliteDB, nil
}

// DB returns the underlying GORM database instance.
func (d *SQLiteDatabase) DB() *gorm.DB {
	return d.db
}

// SqlDB returns the underlying sql.DB instance.
func (d *SQLiteDatabase) SqlDB() *sql.DB {
	return d.sqlDB
}

// applySettings applies SQLite-specific settings.
func (d *SQLiteDatabase) applySettings() error {
	settings := []struct {
		name  string
		value interface{}
	}{
		{"journal_mode", d.config.JournalMode},
		{"synchronous", d.config.SynchronousMode},
		{"foreign_keys", d.config.ForeignKeys},
		{"temp_store", d.config.TempStore},
		{"locking_mode", d.config.LockingMode},
		{"auto_vacuum", d.config.AutoVacuum},
	}

	if d.config.CacheSize > 0 {
		settings = append(settings, struct {
			name  string
			value interface{}
		}{"cache_size", d.config.CacheSize})
	}

	if d.config.PageSize > 0 {
		settings = append(settings, struct {
			name  string
			value interface{}
		}{"page_size", d.config.PageSize})
	}

	for _, setting := range settings {
		var sql string
		switch v := setting.value.(type) {
		case bool:
			if v {
				sql = fmt.Sprintf("PRAGMA %s = ON", setting.name)
			} else {
				sql = fmt.Sprintf("PRAGMA %s = OFF", setting.name)
			}
		case string:
			sql = fmt.Sprintf("PRAGMA %s = %s", setting.name, v)
		case int:
			sql = fmt.Sprintf("PRAGMA %s = %d", setting.name, v)
		}

		if err := d.db.Exec(sql).Error; err != nil {
			return fmt.Errorf("failed to set %s: %w", setting.name, err)
		}
	}

	return nil
}

// Ping checks the database connection.
func (d *SQLiteDatabase) Ping(ctx context.Context) error {
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	return d.sqlDB.PingContext(ctx)
}

// HealthCheck performs a comprehensive database health check.
func (d *SQLiteDatabase) HealthCheck(ctx context.Context) error {
	// Check connection
	if err := d.Ping(ctx); err != nil {
		return fmt.Errorf("database ping failed: %w", err)
	}

	// Check if we can execute a simple query
	var version string
	if err := d.db.WithContext(ctx).Raw("SELECT sqlite_version()").Scan(&version).Error; err != nil {
		return fmt.Errorf("failed to execute test query: %w", err)
	}

	// Check database integrity
	var integrityCheck string
	if err := d.db.WithContext(ctx).Raw("PRAGMA integrity_check").Scan(&integrityCheck).Error; err != nil {
		return fmt.Errorf("failed to check database integrity: %w", err)
	}

	if integrityCheck != "ok" {
		return fmt.Errorf("database integrity check failed: %s", integrityCheck)
	}

	d.logger.Debug("Database health check passed",
		zap.String("sqlite_version", version),
		zap.String("integrity_check", integrityCheck),
	)

	return nil
}

// Migrate runs database migrations for all models.
func (d *SQLiteDatabase) Migrate() error {
	// Auto-migrate models
	if err := d.db.AutoMigrate(
		&model.{{.Service.Name | pascalCase}}{},
		// Add other models here
	); err != nil {
		return fmt.Errorf("failed to auto-migrate models: %w", err)
	}

	d.logger.Info("Database migration completed successfully")
	return nil
}

// Transaction executes a function within a database transaction.
func (d *SQLiteDatabase) Transaction(fn func(*gorm.DB) error) error {
	return d.db.Transaction(fn)
}

// TransactionWithContext executes a function within a database transaction with context.
func (d *SQLiteDatabase) TransactionWithContext(ctx context.Context, fn func(*gorm.DB) error) error {
	return d.db.WithContext(ctx).Transaction(fn)
}

// WithContext returns a new database instance with context.
func (d *SQLiteDatabase) WithContext(ctx context.Context) *gorm.DB {
	return d.db.WithContext(ctx)
}

// Stats returns database connection statistics.
func (d *SQLiteDatabase) Stats() sql.DBStats {
	return d.sqlDB.Stats()
}

// Close closes the database connection.
func (d *SQLiteDatabase) Close() error {
	if d.sqlDB != nil {
		if err := d.sqlDB.Close(); err != nil {
			return fmt.Errorf("failed to close SQLite database connection: %w", err)
		}
		d.logger.Info("SQLite database connection closed successfully")
	}
	return nil
}

// BeginTx starts a transaction with the given options.
func (d *SQLiteDatabase) BeginTx(ctx context.Context, opts *sql.TxOptions) (*gorm.DB, error) {
	tx := d.db.WithContext(ctx).Begin(opts)
	if tx.Error != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", tx.Error)
	}
	return tx, nil
}

// Vacuum performs a VACUUM operation on the database.
func (d *SQLiteDatabase) Vacuum(ctx context.Context) error {
	if err := d.db.WithContext(ctx).Exec("VACUUM").Error; err != nil {
		return fmt.Errorf("failed to vacuum database: %w", err)
	}

	d.logger.Info("Database vacuum completed successfully")
	return nil
}

// Analyze performs an ANALYZE operation on the database.
func (d *SQLiteDatabase) Analyze(ctx context.Context) error {
	if err := d.db.WithContext(ctx).Exec("ANALYZE").Error; err != nil {
		return fmt.Errorf("failed to analyze database: %w", err)
	}

	d.logger.Info("Database analysis completed successfully")
	return nil
}

// GetDatabaseSize returns the size of the database file in bytes.
func (d *SQLiteDatabase) GetDatabaseSize(ctx context.Context) (int64, error) {
	if d.config.InMemory {
		return 0, fmt.Errorf("cannot get file size for in-memory database")
	}

	info, err := os.Stat(d.config.DatabasePath)
	if err != nil {
		return 0, fmt.Errorf("failed to get database file info: %w", err)
	}

	return info.Size(), nil
}

// BackupTo creates a backup of the database.
func (d *SQLiteDatabase) BackupTo(ctx context.Context, backupPath string) error {
	if d.config.InMemory {
		return fmt.Errorf("cannot backup in-memory database")
	}

	// Create backup directory if needed
	dir := filepath.Dir(backupPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create backup directory: %w", err)
	}

	// Use SQLite backup API
	sql := fmt.Sprintf("VACUUM main INTO '%s'", backupPath)
	if err := d.db.WithContext(ctx).Exec(sql).Error; err != nil {
		return fmt.Errorf("failed to backup database: %w", err)
	}

	d.logger.Info("Database backup completed successfully",
		zap.String("backup_path", backupPath),
	)

	return nil
}

// GormLoggerWriter is a custom writer for GORM logger that uses zap.
type GormLoggerWriter struct {
	logger *zap.Logger
}

// NewGormLoggerWriter creates a new GORM logger writer.
func NewGormLoggerWriter(logger *zap.Logger) *GormLoggerWriter {
	return &GormLoggerWriter{logger: logger}
}

// Printf implements the writer interface for GORM logger.
func (w *GormLoggerWriter) Printf(format string, args ...interface{}) {
	w.logger.Debug(fmt.Sprintf(format, args...))
}
{{- end -}}