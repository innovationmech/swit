// Copyright ¬© 2025 jackelyj <dreamerlyj@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

package main

import (
	"context"
	"errors"
	"fmt"
	"math/rand"
	"os"
	"time"

	"github.com/innovationmech/swit/pkg/saga/retry"
	"go.uber.org/zap"
)

// SimulatedService Ê®°Êãü‰∏Ä‰∏™ÂèØËÉΩÂ§±Ë¥•ÁöÑÂ§ñÈÉ®ÊúçÂä°
type SimulatedService struct {
	name          string
	failureRate   float64 // Â§±Ë¥•Áéá (0.0 - 1.0)
	callCount     int
	successCount  int
	failureCount  int
	avgLatency    time.Duration
	logger        *zap.Logger
}

func NewSimulatedService(name string, failureRate float64, avgLatency time.Duration, logger *zap.Logger) *SimulatedService {
	return &SimulatedService{
		name:        name,
		failureRate: failureRate,
		avgLatency:  avgLatency,
		logger:      logger,
	}
}

// Call Ë∞ÉÁî®ÊúçÂä°ÔºàÂèØËÉΩÂ§±Ë¥•Ôºâ
func (s *SimulatedService) Call(ctx context.Context) (string, error) {
	s.callCount++

	// Ê®°ÊãüÁΩëÁªúÂª∂Ëøü
	latency := s.avgLatency + time.Duration(rand.Int63n(int64(s.avgLatency/2)))
	select {
	case <-ctx.Done():
		return "", ctx.Err()
	case <-time.After(latency):
	}

	// Ê†πÊçÆÂ§±Ë¥•ÁéáÂÜ≥ÂÆöÊòØÂê¶Â§±Ë¥•
	if rand.Float64() < s.failureRate {
		s.failureCount++
		s.logger.Warn("service call failed",
			zap.String("service", s.name),
			zap.Int("call_count", s.callCount),
			zap.Int("failure_count", s.failureCount),
		)
		return "", fmt.Errorf("service %s temporarily unavailable", s.name)
	}

	s.successCount++
	s.logger.Info("service call succeeded",
		zap.String("service", s.name),
		zap.Int("call_count", s.callCount),
		zap.Int("success_count", s.successCount),
	)
	return fmt.Sprintf("Response from %s (call #%d)", s.name, s.callCount), nil
}

// GetStats Ëé∑ÂèñÊúçÂä°ÁªüËÆ°‰ø°ÊÅØ
func (s *SimulatedService) GetStats() string {
	successRate := 0.0
	if s.callCount > 0 {
		successRate = float64(s.successCount) / float64(s.callCount) * 100
	}
	return fmt.Sprintf("%s: %d calls, %d success (%.1f%%), %d failures",
		s.name, s.callCount, s.successCount, successRate, s.failureCount)
}

func main() {
	// ÂàùÂßãÂåñÊó•Âøó
	logger, _ := zap.NewDevelopment()
	defer logger.Sync()

	fmt.Println("=== Saga Retry Êú∫Âà∂Á§∫‰æã ===")

	// ËøêË°åÊâÄÊúâÁ§∫‰æã
	runExponentialBackoffExample(logger)
	fmt.Println()

	runLinearBackoffExample(logger)
	fmt.Println()

	runFixedIntervalExample(logger)
	fmt.Println()

	runCircuitBreakerExample(logger)
	fmt.Println()

	runErrorClassificationExample(logger)
	fmt.Println()

	runCallbacksExample(logger)
	fmt.Println()

	runTimeoutExample(logger)
	fmt.Println()

	runJitterComparisonExample(logger)
	fmt.Println()

	fmt.Println("=== ÊâÄÊúâÁ§∫‰æãÂÆåÊàê ===")
}

// runExponentialBackoffExample ÊºîÁ§∫ÊåáÊï∞ÈÄÄÈÅøÈáçËØï
func runExponentialBackoffExample(logger *zap.Logger) {
	fmt.Println("1. ÊåáÊï∞ÈÄÄÈÅøÈáçËØïÁ§∫‰æã")
	fmt.Println("-------------------")

	service := NewSimulatedService("payment-api", 0.6, 50*time.Millisecond, logger)

	config := &retry.RetryConfig{
		MaxAttempts:  5,
		InitialDelay: 100 * time.Millisecond,
		MaxDelay:     2 * time.Second,
	}

	policy := retry.NewExponentialBackoffPolicy(config, 2.0, 0.1)
	executor := retry.NewExecutor(policy, retry.WithLogger(logger))

	ctx := context.Background()
	result, err := executor.Execute(ctx, func(ctx context.Context) (interface{}, error) {
		return service.Call(ctx)
	})

	if err != nil {
		fmt.Printf("‚ùå Êìç‰ΩúÂ§±Ë¥•: %v\n", err)
	} else {
		fmt.Printf("‚úÖ Êìç‰ΩúÊàêÂäü: %v\n", result.Result)
	}
	fmt.Printf("üìä Â∞ùËØïÊ¨°Êï∞: %d, ÊÄªËÄóÊó∂: %v\n", result.Attempts, result.TotalDuration)
	fmt.Printf("üìä %s\n", service.GetStats())
}

// runLinearBackoffExample ÊºîÁ§∫Á∫øÊÄßÈÄÄÈÅøÈáçËØï
func runLinearBackoffExample(logger *zap.Logger) {
	fmt.Println("2. Á∫øÊÄßÈÄÄÈÅøÈáçËØïÁ§∫‰æã")
	fmt.Println("-------------------")

	service := NewSimulatedService("inventory-api", 0.5, 30*time.Millisecond, logger)

	config := &retry.RetryConfig{
		MaxAttempts:  5,
		InitialDelay: 100 * time.Millisecond,
		MaxDelay:     1 * time.Second,
	}

	policy := retry.NewLinearBackoffPolicy(config, 150*time.Millisecond, 0.1)
	executor := retry.NewExecutor(policy, retry.WithLogger(logger))

	ctx := context.Background()
	result, err := executor.Execute(ctx, func(ctx context.Context) (interface{}, error) {
		return service.Call(ctx)
	})

	if err != nil {
		fmt.Printf("‚ùå Êìç‰ΩúÂ§±Ë¥•: %v\n", err)
	} else {
		fmt.Printf("‚úÖ Êìç‰ΩúÊàêÂäü: %v\n", result.Result)
	}
	fmt.Printf("üìä Â∞ùËØïÊ¨°Êï∞: %d, ÊÄªËÄóÊó∂: %v\n", result.Attempts, result.TotalDuration)
	fmt.Printf("üìä %s\n", service.GetStats())
}

// runFixedIntervalExample ÊºîÁ§∫Âõ∫ÂÆöÈó¥ÈöîÈáçËØï
func runFixedIntervalExample(logger *zap.Logger) {
	fmt.Println("3. Âõ∫ÂÆöÈó¥ÈöîÈáçËØïÁ§∫‰æã")
	fmt.Println("-------------------")

	service := NewSimulatedService("notification-api", 0.4, 40*time.Millisecond, logger)

	config := &retry.RetryConfig{
		MaxAttempts:  4,
		InitialDelay: 200 * time.Millisecond,
	}

	policy := retry.NewFixedIntervalPolicy(config, 200*time.Millisecond, 0)
	executor := retry.NewExecutor(policy, retry.WithLogger(logger))

	ctx := context.Background()
	result, err := executor.Execute(ctx, func(ctx context.Context) (interface{}, error) {
		return service.Call(ctx)
	})

	if err != nil {
		fmt.Printf("‚ùå Êìç‰ΩúÂ§±Ë¥•: %v\n", err)
	} else {
		fmt.Printf("‚úÖ Êìç‰ΩúÊàêÂäü: %v\n", result.Result)
	}
	fmt.Printf("üìä Â∞ùËØïÊ¨°Êï∞: %d, ÊÄªËÄóÊó∂: %v\n", result.Attempts, result.TotalDuration)
	fmt.Printf("üìä %s\n", service.GetStats())
}

// runCircuitBreakerExample ÊºîÁ§∫Êñ≠Ë∑ØÂô®Ê®°Âºè
func runCircuitBreakerExample(logger *zap.Logger) {
	fmt.Println("4. Êñ≠Ë∑ØÂô®Ê®°ÂºèÁ§∫‰æã")
	fmt.Println("-------------------")

	// ÂàõÂª∫‰∏Ä‰∏™È´òÂ§±Ë¥•ÁéáÁöÑÊúçÂä°
	service := NewSimulatedService("unstable-api", 0.8, 30*time.Millisecond, logger)

	cbConfig := &retry.CircuitBreakerConfig{
		MaxFailures:         3,
		ResetTimeout:        2 * time.Second,
		HalfOpenMaxRequests: 2,
		SuccessThreshold:    2,
		OnStateChange: func(from, to retry.CircuitState) {
			fmt.Printf("üîÑ Êñ≠Ë∑ØÂô®Áä∂ÊÄÅÂèòÂåñ: %s -> %s\n", from, to)
		},
	}

	retryConfig := &retry.RetryConfig{
		MaxAttempts:  3,
		InitialDelay: 100 * time.Millisecond,
	}
	basePolicy := retry.NewExponentialBackoffPolicy(retryConfig, 2.0, 0)

	cb := retry.NewCircuitBreaker(cbConfig, basePolicy)
	executor := retry.NewExecutor(cb, retry.WithLogger(logger))

	ctx := context.Background()

	// Â∞ùËØïÂ§öÊ¨°Ë∞ÉÁî®ÔºåËßÇÂØüÊñ≠Ë∑ØÂô®Ë°å‰∏∫
	for i := 1; i <= 8; i++ {
		fmt.Printf("\nÁ¨¨ %d Ê¨°Ë∞ÉÁî® (Êñ≠Ë∑ØÂô®Áä∂ÊÄÅ: %s):\n", i, cb.GetState())

		result, err := executor.Execute(ctx, func(ctx context.Context) (interface{}, error) {
			return service.Call(ctx)
		})

		if err != nil {
			if errors.Is(err, retry.ErrCircuitBreakerOpen) {
				fmt.Printf("‚ö° Êñ≠Ë∑ØÂô®ÊâìÂºÄÔºåÂø´ÈÄüÂ§±Ë¥•\n")
			} else {
				fmt.Printf("‚ùå Êìç‰ΩúÂ§±Ë¥•: %v (Â∞ùËØï %d Ê¨°)\n", err, result.Attempts)
			}
		} else {
			fmt.Printf("‚úÖ Êìç‰ΩúÊàêÂäü: %v (Â∞ùËØï %d Ê¨°)\n", result.Result, result.Attempts)
		}

		// Áü≠ÊöÇÂª∂Ëøü
		time.Sleep(300 * time.Millisecond)
	}

	fmt.Printf("\nüìä ÊúÄÁªàÊñ≠Ë∑ØÂô®Áä∂ÊÄÅ: %s\n", cb.GetState())
	fmt.Printf("üìä %s\n", service.GetStats())
	metrics := cb.GetMetrics()
	fmt.Printf("üìä ËøûÁª≠Â§±Ë¥•: %d, ËøûÁª≠ÊàêÂäü: %d\n",
		metrics.ConsecutiveFailures, metrics.ConsecutiveSuccesses)
}

// runErrorClassificationExample ÊºîÁ§∫ÈîôËØØÂàÜÁ±ª
func runErrorClassificationExample(logger *zap.Logger) {
	fmt.Println("5. ÈîôËØØÂàÜÁ±ªÁ§∫‰æã")
	fmt.Println("-------------------")

	var (
		errTemporary  = errors.New("temporary error")
		errPermanent  = errors.New("permanent error")
		errValidation = errors.New("validation error")
	)

	config := &retry.RetryConfig{
		MaxAttempts: 3,
		RetryableErrors: []error{
			errTemporary,
		},
		NonRetryableErrors: []error{
			errPermanent,
			errValidation,
		},
		InitialDelay: 100 * time.Millisecond,
	}

	policy := retry.NewFixedIntervalPolicy(config, 100*time.Millisecond, 0)
	executor := retry.NewExecutor(policy, retry.WithLogger(logger))

	ctx := context.Background()

	// ÊµãËØïÂèØÈáçËØïÈîôËØØ
	fmt.Println("ÊµãËØïÂèØÈáçËØïÈîôËØØ (temporary error):")
	attemptCount := 0
	result, err := executor.Execute(ctx, func(ctx context.Context) (interface{}, error) {
		attemptCount++
		if attemptCount < 2 {
			return nil, errTemporary
		}
		return "success", nil
	})
	if err != nil {
		fmt.Printf("‚ùå Â§±Ë¥•: %v (Â∞ùËØï %d Ê¨°)\n", err, result.Attempts)
	} else {
		fmt.Printf("‚úÖ ÊàêÂäü: %v (Â∞ùËØï %d Ê¨°)\n", result.Result, result.Attempts)
	}

	// ÊµãËØïÊ∞∏‰πÖÊÄßÈîôËØØ
	fmt.Println("\nÊµãËØïÊ∞∏‰πÖÊÄßÈîôËØØ (permanent error):")
	result, err = executor.Execute(ctx, func(ctx context.Context) (interface{}, error) {
		return nil, errPermanent
	})
	if err != nil {
		fmt.Printf("‚ùå Â§±Ë¥•: %v (Â∞ùËØï %d Ê¨° - ‰∏çÈáçËØï)\n", err, result.Attempts)
	}

	// ÊµãËØïÈ™åËØÅÈîôËØØ
	fmt.Println("\nÊµãËØïÈ™åËØÅÈîôËØØ (validation error):")
	result, err = executor.Execute(ctx, func(ctx context.Context) (interface{}, error) {
		return nil, errValidation
	})
	if err != nil {
		fmt.Printf("‚ùå Â§±Ë¥•: %v (Â∞ùËØï %d Ê¨° - ‰∏çÈáçËØï)\n", err, result.Attempts)
	}
}

// runCallbacksExample ÊºîÁ§∫ÂõûË∞ÉÂáΩÊï∞
func runCallbacksExample(logger *zap.Logger) {
	fmt.Println("6. ÂõûË∞ÉÂáΩÊï∞Á§∫‰æã")
	fmt.Println("-------------------")

	service := NewSimulatedService("callback-api", 0.6, 30*time.Millisecond, logger)

	config := &retry.RetryConfig{
		MaxAttempts:  4,
		InitialDelay: 100 * time.Millisecond,
	}

	policy := retry.NewExponentialBackoffPolicy(config, 2.0, 0)

	executor := retry.NewExecutor(policy, retry.WithLogger(logger)).
		OnRetry(func(attempt int, err error, delay time.Duration) {
			fmt.Printf("üîÑ ÂáÜÂ§áÈáçËØï: Â∞ùËØï #%d, ÈîôËØØ: %v, Âª∂Ëøü: %v\n", attempt+1, err, delay)
		}).
		OnSuccess(func(attempt int, duration time.Duration, result interface{}) {
			fmt.Printf("‚úÖ Êìç‰ΩúÊàêÂäü: Â∞ùËØï %d Ê¨°, ÊÄªËÄóÊó∂: %v\n", attempt, duration)
		}).
		OnFailure(func(attempts int, duration time.Duration, lastErr error) {
			fmt.Printf("‚ùå ÊâÄÊúâÈáçËØïÂ§±Ë¥•: Â∞ùËØï %d Ê¨°, ÊÄªËÄóÊó∂: %v, ÊúÄÂêéÈîôËØØ: %v\n",
				attempts, duration, lastErr)
		})

	ctx := context.Background()
	result, err := executor.Execute(ctx, func(ctx context.Context) (interface{}, error) {
		return service.Call(ctx)
	})

	if err == nil {
		fmt.Printf("\nüìä ÁªìÊûú: %v\n", result.Result)
	}
	fmt.Printf("üìä %s\n", service.GetStats())
}

// runTimeoutExample ÊºîÁ§∫Ë∂ÖÊó∂ÊéßÂà∂
func runTimeoutExample(logger *zap.Logger) {
	fmt.Println("7. Ë∂ÖÊó∂ÊéßÂà∂Á§∫‰æã")
	fmt.Println("-------------------")

	// ÂàõÂª∫‰∏Ä‰∏™ÊÖ¢ÈÄüÊúçÂä°
	service := NewSimulatedService("slow-api", 0.7, 200*time.Millisecond, logger)

	config := &retry.RetryConfig{
		MaxAttempts:  10,
		InitialDelay: 100 * time.Millisecond,
	}

	policy := retry.NewFixedIntervalPolicy(config, 200*time.Millisecond, 0)
	executor := retry.NewExecutor(policy, retry.WithLogger(logger))

	ctx := context.Background()

	// ËÆæÁΩÆËæÉÁü≠ÁöÑË∂ÖÊó∂Êó∂Èó¥
	timeout := 800 * time.Millisecond
	fmt.Printf("ËÆæÁΩÆË∂ÖÊó∂: %v\n", timeout)

	result, err := executor.ExecuteWithTimeout(ctx, timeout, func(ctx context.Context) (interface{}, error) {
		return service.Call(ctx)
	})

	if err != nil {
		if errors.Is(err, context.DeadlineExceeded) {
			fmt.Printf("‚è±Ô∏è Ë∂ÖÊó∂: Â∞ùËØï‰∫Ü %d Ê¨°ÂêéË∂ÖÊó∂\n", result.Attempts)
		} else {
			fmt.Printf("‚ùå Â§±Ë¥•: %v (Â∞ùËØï %d Ê¨°)\n", err, result.Attempts)
		}
	} else {
		fmt.Printf("‚úÖ ÊàêÂäü: %v (Â∞ùËØï %d Ê¨°)\n", result.Result, result.Attempts)
	}
	fmt.Printf("üìä ÊÄªËÄóÊó∂: %v\n", result.TotalDuration)
	fmt.Printf("üìä %s\n", service.GetStats())
}

// runJitterComparisonExample ÊºîÁ§∫‰∏çÂêåÊäñÂä®Á±ªÂûãÁöÑÊïàÊûú
func runJitterComparisonExample(logger *zap.Logger) {
	fmt.Println("8. ÊäñÂä®Á±ªÂûãÊØîËæÉÁ§∫‰æã")
	fmt.Println("-------------------")

	config := &retry.RetryConfig{
		MaxAttempts:  5,
		InitialDelay: 100 * time.Millisecond,
		MaxDelay:     2 * time.Second,
	}

	jitterTypes := []struct {
		name       string
		jitterType retry.JitterType
	}{
		{"Êó†ÊäñÂä®", -1},
		{"Full Jitter", retry.JitterTypeFull},
		{"Equal Jitter", retry.JitterTypeEqual},
		{"Decorrelated Jitter", retry.JitterTypeDecorelated},
	}

	for _, jt := range jitterTypes {
		fmt.Printf("\n%s:\n", jt.name)

		policy := retry.NewExponentialBackoffPolicy(config, 2.0, 0.3)
		if jt.jitterType >= 0 {
			policy.JitterType = jt.jitterType
		} else {
			policy.Jitter = 0 // Êó†ÊäñÂä®
		}

		// ÊâìÂç∞Ââç5Ê¨°ÈáçËØïÁöÑÂª∂Ëøü
		fmt.Print("  Âª∂ËøüÂ∫èÂàó: ")
		for i := 1; i <= 5; i++ {
			delay := policy.GetRetryDelay(i)
			fmt.Printf("%v ", delay.Round(time.Millisecond))
		}
		fmt.Println()
	}
}

// ËæÖÂä©ÂáΩÊï∞ÔºöËøêË°åÁ§∫‰æãÊó∂Ê£ÄÊü•ÁéØÂ¢É
func init() {
	// ËÆæÁΩÆÈöèÊú∫ÁßçÂ≠ê
	rand.Seed(time.Now().UnixNano())

	// Ê£ÄÊü•ÊòØÂê¶Âú® CI ÁéØÂ¢É‰∏≠
	if os.Getenv("CI") != "" {
		fmt.Println("Ê≥®ÊÑèÔºöÂú® CI ÁéØÂ¢É‰∏≠ËøêË°åÔºåÊüê‰∫õÁ§∫‰æãÂèØËÉΩË°®Áé∞‰∏çÂêå")
	}
}

