#!/bin/bash

# æ—¥å¿—åˆ†æå·¥å…·
# Copyright (c) 2024 SWIT Framework Authors

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# é¢œè‰²å®šä¹‰
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# æ—¥å¿—å‡½æ•°
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_header() {
    echo -e "${PURPLE}[LOG-PARSER]${NC} $1"
}

# æ˜¾ç¤ºæ¬¢è¿ä¿¡æ¯
show_welcome() {
    echo "======================================================================"
    echo -e "${BLUE}ğŸ“‹ SWIT æ¡†æ¶åˆ†å¸ƒå¼è¿½è¸ªæ—¥å¿—åˆ†æå·¥å…·${NC}"
    echo "======================================================================"
    echo -e "${YELLOW}æœ¬å·¥å…·ç”¨äºåˆ†æåˆ†å¸ƒå¼è¿½è¸ªç³»ç»Ÿçš„æ—¥å¿—ï¼š${NC}"
    echo "  ğŸ” å¤šæœåŠ¡æ—¥å¿—èšåˆåˆ†æ"
    echo "  ğŸ“Š é”™è¯¯æ¨¡å¼è¯†åˆ«å’Œç»Ÿè®¡"
    echo "  â±ï¸  æ€§èƒ½æŒ‡æ ‡æå–"
    echo "  ğŸ¯ è¿½è¸ªIDå…³è”åˆ†æ"
    echo "  ğŸ“ˆ è¶‹åŠ¿åˆ†æå’ŒæŠ¥å‘Šç”Ÿæˆ"
    echo
}

# æ˜¾ç¤ºä½¿ç”¨è¯´æ˜
show_usage() {
    echo "Usage: $0 [options] [log-files...]"
    echo
    echo "Options:"
    echo "  -h, --help                  æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯"
    echo "  -s, --source=TYPE           æ—¥å¿—æºç±»å‹ (é»˜è®¤: auto)"
    echo "                              å¯é€‰: docker, file, journald, auto"
    echo "  -f, --filter=PATTERN        æ—¥å¿—è¿‡æ»¤æ¨¡å¼ (æ”¯æŒæ­£åˆ™è¡¨è¾¾å¼)"
    echo "  -l, --level=LEVEL           æ—¥å¿—çº§åˆ«è¿‡æ»¤ (é»˜è®¤: all)"
    echo "                              å¯é€‰: debug, info, warn, error, fatal, all"
    echo "  -t, --time-range=RANGE      æ—¶é—´èŒƒå›´ (é»˜è®¤: 1h)"
    echo "                              æ ¼å¼: 1h, 30m, 2d, '2024-01-01 12:00' '2024-01-01 18:00'"
    echo "  --service=NAME              ç‰¹å®šæœåŠ¡æ—¥å¿— (å¯å¤šæ¬¡ä½¿ç”¨)"
    echo "  --trace-id=ID               ç‰¹å®šè¿½è¸ªIDçš„ç›¸å…³æ—¥å¿—"
    echo "  --follow                    å®æ—¶è·Ÿè¸ªæ—¥å¿—è¾“å‡º"
    echo "  --output=FORMAT             è¾“å‡ºæ ¼å¼ (é»˜è®¤: text)"
    echo "                              å¯é€‰: text, json, csv, html"
    echo "  --output-file=FILE          è¾“å‡ºåˆ°æ–‡ä»¶"
    echo "  --analyze                   æ‰§è¡Œæ·±åº¦åˆ†æ"
    echo "  --stats                     æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯"
    echo "  --errors-only               åªæ˜¾ç¤ºé”™è¯¯æ—¥å¿—"
    echo "  --performance               æå–æ€§èƒ½ç›¸å…³æ—¥å¿—"
    echo "  --highlight=PATTERN         é«˜äº®æ˜¾ç¤ºåŒ¹é…çš„æ¨¡å¼"
    echo "  --context=N                 æ˜¾ç¤ºåŒ¹é…è¡Œçš„å‰åNè¡Œä¸Šä¸‹æ–‡"
    echo "  --max-lines=N               æœ€å¤§æ˜¾ç¤ºè¡Œæ•° (é»˜è®¤: 1000)"
    echo "  --verbose                   è¯¦ç»†è¾“å‡º"
    echo "  --quiet                     é™é»˜æ¨¡å¼"
    echo
    echo "Log Sources:"
    echo "  docker        Docker å®¹å™¨æ—¥å¿—"
    echo "  file          æœ¬åœ°æ—¥å¿—æ–‡ä»¶"
    echo "  journald      ç³»ç»Ÿ journald æ—¥å¿—"
    echo "  auto          è‡ªåŠ¨æ£€æµ‹æ—¥å¿—æº"
    echo
    echo "Time Range Examples:"
    echo "  1h, 30m, 2d                    ç›¸å¯¹æ—¶é—´"
    echo "  '2024-01-01 12:00'             ç»å¯¹æ—¶é—´ç‚¹"
    echo "  '2024-01-01' '2024-01-02'      æ—¶é—´åŒºé—´"
    echo
    echo "Examples:"
    echo "  $0                                       # åˆ†ææœ€è¿‘1å°æ—¶çš„æ‰€æœ‰æ—¥å¿—"
    echo "  $0 --service=order-service --errors-only  # åªçœ‹è®¢å•æœåŠ¡çš„é”™è¯¯"
    echo "  $0 --trace-id=abc123 --analyze           # åˆ†æç‰¹å®šè¿½è¸ªçš„å®Œæ•´é“¾è·¯"
    echo "  $0 --follow --highlight='ERROR|WARN'     # å®æ—¶è·Ÿè¸ªå¹¶é«˜äº®é”™è¯¯"
    echo "  $0 -t 2h --performance --output=json    # 2å°æ—¶æ€§èƒ½æ•°æ®JSONæ ¼å¼"
    echo "  $0 /var/log/app.log --stats              # åˆ†ææŒ‡å®šæ–‡ä»¶çš„ç»Ÿè®¡ä¿¡æ¯"
}

# æ£€æŸ¥ä¾èµ–å·¥å…·
check_dependencies() {
    local missing_tools=()
    local optional_missing=()
    
    # åŸºç¡€å·¥å…·
    for tool in jq bc; do
        if ! command -v $tool &> /dev/null; then
            missing_tools+=("$tool")
        fi
    done
    
    # æ—¥å¿—ç›¸å…³å·¥å…·
    if ! command -v docker &> /dev/null; then
        optional_missing+=("docker")
    fi
    
    if ! command -v journalctl &> /dev/null; then
        optional_missing+=("journalctl")
    fi
    
    # æ–‡æœ¬å¤„ç†å·¥å…·
    for tool in awk sed grep; do
        if ! command -v $tool &> /dev/null; then
            missing_tools+=("$tool")
        fi
    done
    
    if [ ${#missing_tools[@]} -gt 0 ]; then
        log_error "ç¼ºå°‘å¿…éœ€å·¥å…·: ${missing_tools[*]}"
        echo "å®‰è£…æ–¹æ³•ï¼š"
        echo "  macOS: brew install jq bc"
        echo "  Ubuntu: sudo apt-get install jq bc"
        exit 1
    fi
    
    if [ ${#optional_missing[@]} -gt 0 ] && [ "$VERBOSE" = "true" ]; then
        log_warning "ç¼ºå°‘å¯é€‰å·¥å…·: ${optional_missing[*]}"
        log_info "æŸäº›æ—¥å¿—æºå¯èƒ½ä¸å¯ç”¨"
    fi
}

# æ£€æµ‹æ—¥å¿—æº
detect_log_sources() {
    log_header "æ£€æµ‹å¯ç”¨æ—¥å¿—æº"
    
    local sources=()
    
    # æ£€æŸ¥ Docker å®¹å™¨æ—¥å¿—
    if command -v docker &> /dev/null && docker info >/dev/null 2>&1; then
        local container_count
        container_count=$(docker ps --filter "name=order-service\|payment-service\|inventory-service\|jaeger" --format "{{.Names}}" | wc -l)
        if [ "$container_count" -gt 0 ]; then
            sources+=("docker:$container_count ä¸ªç›¸å…³å®¹å™¨")
            log_success "å‘ç° Docker å®¹å™¨æ—¥å¿— ($container_count ä¸ªå®¹å™¨)"
        fi
    fi
    
    # æ£€æŸ¥æœ¬åœ°æ—¥å¿—æ–‡ä»¶
    local log_files=()
    for pattern in "/var/log/*.log" "/tmp/*.log" "$PROJECT_ROOT/logs/*.log"; do
        for file in $pattern; do
            if [ -f "$file" ] && [ -r "$file" ]; then
                log_files+=("$file")
            fi
        done
    done
    
    if [ ${#log_files[@]} -gt 0 ]; then
        sources+=("file:${#log_files[@]} ä¸ªæ—¥å¿—æ–‡ä»¶")
        log_success "å‘ç°æœ¬åœ°æ—¥å¿—æ–‡ä»¶ (${#log_files[@]} ä¸ªæ–‡ä»¶)"
    fi
    
    # æ£€æŸ¥ journald
    if command -v journalctl &> /dev/null; then
        sources+=("journald:ç³»ç»Ÿæ—¥å¿—")
        log_success "å‘ç° systemd journal æ—¥å¿—"
    fi
    
    if [ ${#sources[@]} -eq 0 ]; then
        log_warning "æœªå‘ç°ä»»ä½•æ—¥å¿—æº"
        return 1
    fi
    
    printf '%s\n' "${sources[@]}"
}

# è§£ææ—¶é—´èŒƒå›´
parse_time_range() {
    local time_input="$1"
    local current_timestamp=$(date +%s)
    
    # ç›¸å¯¹æ—¶é—´æ ¼å¼ (1h, 30m, 2d)
    if [[ $time_input =~ ^([0-9]+)([hmsd])$ ]]; then
        local value="${BASH_REMATCH[1]}"
        local unit="${BASH_REMATCH[2]}"
        local seconds=0
        
        case $unit in
            s) seconds=$value ;;
            m) seconds=$((value * 60)) ;;
            h) seconds=$((value * 3600)) ;;
            d) seconds=$((value * 86400)) ;;
        esac
        
        local start_time=$((current_timestamp - seconds))
        echo "$start_time $current_timestamp"
        return 0
    fi
    
    # ç»å¯¹æ—¶é—´æ ¼å¼
    if [[ $time_input =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2} ]]; then
        local timestamp
        timestamp=$(date -d "$time_input" +%s 2>/dev/null || date -j -f "%Y-%m-%d %H:%M" "$time_input" +%s 2>/dev/null)
        if [ $? -eq 0 ]; then
            echo "$timestamp $current_timestamp"
            return 0
        fi
    fi
    
    log_error "æ— æ³•è§£ææ—¶é—´æ ¼å¼: $time_input"
    return 1
}

# ä» Docker è·å–æ—¥å¿—
get_docker_logs() {
    local service="$1"
    local since="$2"
    local until="$3"
    
    local container_names
    if [ -n "$service" ]; then
        container_names=$(docker ps --filter "name=$service" --format "{{.Names}}" 2>/dev/null)
    else
        container_names=$(docker ps --filter "name=order-service\|payment-service\|inventory-service\|jaeger" --format "{{.Names}}" 2>/dev/null)
    fi
    
    if [ -z "$container_names" ]; then
        log_warning "æœªæ‰¾åˆ°åŒ¹é…çš„ Docker å®¹å™¨"
        return 1
    fi
    
    local docker_args=""
    if [ -n "$since" ]; then
        docker_args="$docker_args --since $(date -d @$since '+%Y-%m-%dT%H:%M:%S')"
    fi
    if [ -n "$until" ]; then
        docker_args="$docker_args --until $(date -d @$until '+%Y-%m-%dT%H:%M:%S')"
    fi
    
    echo "$container_names" | while IFS= read -r container; do
        log_info "è·å–å®¹å™¨æ—¥å¿—: $container"
        eval "docker logs $docker_args $container 2>&1" | sed "s/^/[$container] /"
    done
}

# ä»æ–‡ä»¶è·å–æ—¥å¿—
get_file_logs() {
    local files="$1"
    local since="$2"
    local until="$3"
    
    if [ -z "$files" ]; then
        # è‡ªåŠ¨å‘ç°æ—¥å¿—æ–‡ä»¶
        files=$(find /var/log "$PROJECT_ROOT" -name "*.log" -type f -readable 2>/dev/null | head -10)
    fi
    
    if [ -z "$files" ]; then
        log_warning "æœªæ‰¾åˆ°æ—¥å¿—æ–‡ä»¶"
        return 1
    fi
    
    echo "$files" | while IFS= read -r file; do
        if [ ! -f "$file" ] || [ ! -r "$file" ]; then
            log_warning "æ— æ³•è¯»å–æ–‡ä»¶: $file"
            continue
        fi
        
        log_info "åˆ†ææ—¥å¿—æ–‡ä»¶: $file"
        
        # ç®€å•çš„æ—¶é—´è¿‡æ»¤ (åŸºäºè¡Œå†…å®¹ä¸­çš„æ—¶é—´æˆ³)
        local awk_filter='1'
        if [ -n "$since" ]; then
            local since_date
            since_date=$(date -d "@$since" '+%Y-%m-%d %H:%M:%S')
            awk_filter="/$since_date/,\$0"
        fi
        
        awk "$awk_filter" "$file" | sed "s/^/[$(basename "$file")] /"
    done
}

# ä» journald è·å–æ—¥å¿—
get_journald_logs() {
    local service="$1"
    local since="$2"
    local until="$3"
    
    local journal_args=()
    
    if [ -n "$service" ]; then
        journal_args+=("--unit=$service")
    fi
    
    if [ -n "$since" ]; then
        journal_args+=("--since=$(date -d @$since '+%Y-%m-%d %H:%M:%S')")
    fi
    
    if [ -n "$until" ]; then
        journal_args+=("--until=$(date -d @$until '+%Y-%m-%d %H:%M:%S')")
    fi
    
    journalctl "${journal_args[@]}" --no-pager 2>/dev/null || {
        log_warning "æ— æ³•è®¿é—® journald æ—¥å¿—"
        return 1
    }
}

# è¿‡æ»¤æ—¥å¿—çº§åˆ«
filter_log_level() {
    local level="$1"
    
    case "$level" in
        "debug") grep -iE "(DEBUG|DBG)" ;;
        "info") grep -iE "(INFO|INF)" ;;
        "warn") grep -iE "(WARN|WARNING)" ;;
        "error") grep -iE "(ERROR|ERR|FATAL|CRITICAL)" ;;
        "fatal") grep -iE "(FATAL|CRITICAL)" ;;
        "all"|*) cat ;;
    esac
}

# åº”ç”¨è¿‡æ»¤å™¨
apply_filters() {
    local logs="$1"
    
    # åº”ç”¨çº§åˆ«è¿‡æ»¤
    if [ "$LOG_LEVEL" != "all" ]; then
        logs=$(echo "$logs" | filter_log_level "$LOG_LEVEL")
    fi
    
    # åº”ç”¨æ¨¡å¼è¿‡æ»¤
    if [ -n "$FILTER_PATTERN" ]; then
        logs=$(echo "$logs" | grep -E "$FILTER_PATTERN")
    fi
    
    # åªæ˜¾ç¤ºé”™è¯¯
    if [ "$ERRORS_ONLY" = "true" ]; then
        logs=$(echo "$logs" | filter_log_level "error")
    fi
    
    # æ€§èƒ½ç›¸å…³æ—¥å¿—
    if [ "$PERFORMANCE" = "true" ]; then
        logs=$(echo "$logs" | grep -iE "(duration|latency|response_time|ms|sec|slow|timeout|performance)")
    fi
    
    # è¿½è¸ªIDè¿‡æ»¤
    if [ -n "$TRACE_ID" ]; then
        logs=$(echo "$logs" | grep -i "$TRACE_ID")
    fi
    
    # é™åˆ¶è¡Œæ•°
    if [ -n "$MAX_LINES" ] && [ "$MAX_LINES" -gt 0 ]; then
        logs=$(echo "$logs" | head -n "$MAX_LINES")
    fi
    
    echo "$logs"
}

# é«˜äº®æ˜¾ç¤º
highlight_output() {
    local logs="$1"
    local pattern="$2"
    
    if [ -z "$pattern" ]; then
        echo "$logs"
        return 0
    fi
    
    # ä½¿ç”¨é¢œè‰²é«˜äº®åŒ¹é…çš„æ¨¡å¼
    echo "$logs" | sed -E "s/($pattern)/${RED}\1${NC}/gi"
}

# æ·»åŠ ä¸Šä¸‹æ–‡è¡Œ
add_context() {
    local logs="$1"
    local context_lines="$2"
    
    if [ -z "$context_lines" ] || [ "$context_lines" -eq 0 ]; then
        echo "$logs"
        return 0
    fi
    
    # è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„ä¸Šä¸‹æ–‡å®ç°
    # å®é™…åº”ç”¨ä¸­éœ€è¦æ›´å¤æ‚çš„é€»è¾‘æ¥å¤„ç†å¤šæ–‡ä»¶æ—¥å¿—
    echo "$logs"
}

# ç»Ÿè®¡åˆ†æ
analyze_logs() {
    local logs="$1"
    
    log_header "æ—¥å¿—åˆ†æç»Ÿè®¡"
    
    local total_lines
    total_lines=$(echo "$logs" | wc -l)
    
    echo "ğŸ“Š æ€»è§ˆç»Ÿè®¡:"
    echo "  æ€»æ—¥å¿—è¡Œæ•°: $total_lines"
    
    # æ—¥å¿—çº§åˆ«ç»Ÿè®¡
    local debug_count info_count warn_count error_count
    debug_count=$(echo "$logs" | grep -icE "(DEBUG|DBG)" || echo "0")
    info_count=$(echo "$logs" | grep -icE "(INFO|INF)" || echo "0")
    warn_count=$(echo "$logs" | grep -icE "(WARN|WARNING)" || echo "0")
    error_count=$(echo "$logs" | grep -icE "(ERROR|ERR|FATAL|CRITICAL)" || echo "0")
    
    echo
    echo "ğŸ“ˆ æ—¥å¿—çº§åˆ«åˆ†å¸ƒ:"
    echo "  DEBUG: $debug_count"
    echo "  INFO:  $info_count"
    echo "  WARN:  $warn_count"
    echo "  ERROR: $error_count"
    
    # æœåŠ¡ç»Ÿè®¡ 
    echo
    echo "ğŸ·ï¸  æœåŠ¡åˆ†å¸ƒ:"
    echo "$logs" | grep -oE '\[(.*?)\]' | sort | uniq -c | sort -nr | head -10 | while read count service; do
        printf "  %-20s: %s\n" "$service" "$count"
    done
    
    # é”™è¯¯æ¨¡å¼åˆ†æ
    if [ "$error_count" -gt 0 ]; then
        echo
        echo "âŒ å¸¸è§é”™è¯¯æ¨¡å¼:"
        echo "$logs" | grep -iE "(ERROR|ERR|FATAL|CRITICAL)" | \
            sed -E 's/.*[Ee]rror[^:]*:?[[:space:]]*(.*)/\1/' | \
            sed -E 's/[0-9]+//g' | \
            sort | uniq -c | sort -nr | head -5 | \
            while read count pattern; do
                printf "  %-50s: %sæ¬¡\n" "${pattern:0:47}..." "$count"
            done
    fi
    
    # æ€§èƒ½æŒ‡æ ‡æå–
    echo
    echo "â±ï¸  æ€§èƒ½æŒ‡æ ‡:"
    local duration_logs
    duration_logs=$(echo "$logs" | grep -iE "(duration|latency|response_time|took|elapsed)")
    
    if [ -n "$duration_logs" ]; then
        local durations
        durations=$(echo "$duration_logs" | grep -oE '[0-9]+\.?[0-9]*\s*(ms|sec|s)' | head -20)
        
        if [ -n "$durations" ]; then
            echo "  æ£€æµ‹åˆ°çš„å“åº”æ—¶é—´æ ·æœ¬:"
            echo "$durations" | head -10 | sed 's/^/    /'
        fi
    else
        echo "  æœªæ£€æµ‹åˆ°æ€§èƒ½ç›¸å…³æ—¥å¿—"
    fi
    
    # è¿½è¸ªIDåˆ†æ
    echo
    echo "ğŸ” è¿½è¸ªIDåˆ†æ:"
    local trace_ids
    trace_ids=$(echo "$logs" | grep -oE 'trace[_-]?id[=:]?\s*[a-fA-F0-9-]{8,}' | head -10)
    
    if [ -n "$trace_ids" ]; then
        local unique_traces
        unique_traces=$(echo "$trace_ids" | sort | uniq | wc -l)
        echo "  æ£€æµ‹åˆ° $unique_traces ä¸ªä¸åŒçš„è¿½è¸ªID"
        echo "  æ ·æœ¬è¿½è¸ªID:"
        echo "$trace_ids" | head -5 | sed 's/^/    /'
    else
        echo "  æœªæ£€æµ‹åˆ°è¿½è¸ªID"
    fi
}

# ç”ŸæˆæŠ¥å‘Š
generate_report() {
    local logs="$1"
    local format="$2"
    
    case "$format" in
        "json")
            generate_json_report "$logs"
            ;;
        "csv")
            generate_csv_report "$logs"
            ;;
        "html")
            generate_html_report "$logs"
            ;;
        "text"|*)
            echo "$logs"
            ;;
    esac
}

# ç”Ÿæˆ JSON æŠ¥å‘Š
generate_json_report() {
    local logs="$1"
    
    local total_lines debug_count info_count warn_count error_count
    total_lines=$(echo "$logs" | wc -l)
    debug_count=$(echo "$logs" | grep -icE "(DEBUG|DBG)" || echo "0")
    info_count=$(echo "$logs" | grep -icE "(INFO|INF)" || echo "0")
    warn_count=$(echo "$logs" | grep -icE "(WARN|WARNING)" || echo "0")
    error_count=$(echo "$logs" | grep -icE "(ERROR|ERR|FATAL|CRITICAL)" || echo "0")
    
    cat << EOF
{
    "generated_at": "$(date -u '+%Y-%m-%dT%H:%M:%SZ')",
    "analysis_params": {
        "time_range": "$TIME_RANGE",
        "log_level": "$LOG_LEVEL",
        "source": "$LOG_SOURCE",
        "services": $(printf '%s\n' "${SERVICES[@]}" | jq -R . | jq -s .),
        "trace_id": "$TRACE_ID"
    },
    "statistics": {
        "total_lines": $total_lines,
        "by_level": {
            "debug": $debug_count,
            "info": $info_count,
            "warn": $warn_count,
            "error": $error_count
        }
    },
    "sample_logs": $(echo "$logs" | head -50 | jq -R . | jq -s .)
}
EOF
}

# ç”Ÿæˆ CSV æŠ¥å‘Š
generate_csv_report() {
    local logs="$1"
    
    echo "timestamp,level,service,message"
    echo "$logs" | while IFS= read -r line; do
        # ç®€åŒ–çš„ CSV è¾“å‡ºï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„è§£æ
        local timestamp="$(date)"
        local level="INFO"
        local service="unknown"
        local message="$line"
        
        # å°è¯•æå–ä¿¡æ¯
        if [[ $line =~ \[([^\]]+)\] ]]; then
            service="${BASH_REMATCH[1]}"
        fi
        
        if [[ $line =~ (DEBUG|INFO|WARN|ERROR|FATAL) ]]; then
            level="${BASH_REMATCH[1]}"
        fi
        
        echo "\"$timestamp\",\"$level\",\"$service\",\"$message\""
    done | head -1000
}

# ç”Ÿæˆ HTML æŠ¥å‘Š
generate_html_report() {
    local logs="$1"
    
    cat << EOF
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æ—¥å¿—åˆ†ææŠ¥å‘Š</title>
    <style>
        body { font-family: monospace; background: #1a1a1a; color: #e0e0e0; padding: 20px; }
        .log-line { margin: 2px 0; padding: 2px 5px; border-radius: 3px; }
        .debug { color: #888; }
        .info { color: #4a90e2; }
        .warn { color: #f5a623; background: rgba(245, 166, 35, 0.1); }
        .error { color: #d0021b; background: rgba(208, 2, 27, 0.1); }
        .highlight { background: yellow; color: black; }
        .header { color: #50e3c2; font-size: 1.2em; margin: 20px 0 10px 0; }
        pre { white-space: pre-wrap; word-wrap: break-word; }
    </style>
</head>
<body>
    <div class="header">ğŸ“‹ æ—¥å¿—åˆ†ææŠ¥å‘Š</div>
    <div>ç”Ÿæˆæ—¶é—´: $(date)</div>
    <div>åˆ†æèŒƒå›´: $TIME_RANGE</div>
    <div class="header">æ—¥å¿—å†…å®¹:</div>
    <pre>$(echo "$logs" | sed -E 's/(DEBUG|DBG)/<span class="debug">\1<\/span>/gi' | \
                              sed -E 's/(INFO|INF)/<span class="info">\1<\/span>/gi' | \
                              sed -E 's/(WARN|WARNING)/<span class="warn">\1<\/span>/gi' | \
                              sed -E 's/(ERROR|ERR|FATAL|CRITICAL)/<span class="error">\1<\/span>/gi')</pre>
</body>
</html>
EOF
}

# ä¸»å‡½æ•°
main() {
    # é»˜è®¤å‚æ•°
    LOG_SOURCE="auto"
    FILTER_PATTERN=""
    LOG_LEVEL="all"
    TIME_RANGE="1h"
    SERVICES=()
    TRACE_ID=""
    FOLLOW="false"
    OUTPUT_FORMAT="text"
    OUTPUT_FILE=""
    ANALYZE="false"
    STATS="false"
    ERRORS_ONLY="false"
    PERFORMANCE="false"
    HIGHLIGHT_PATTERN=""
    CONTEXT_LINES=""
    MAX_LINES="1000"
    VERBOSE="false"
    QUIET="false"
    LOG_FILES=()
    
    # è§£æå‘½ä»¤è¡Œå‚æ•°
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                exit 0
                ;;
            -s|--source)
                LOG_SOURCE="$2"
                shift 2
                ;;
            --source=*)
                LOG_SOURCE="${1#*=}"
                shift
                ;;
            -f|--filter)
                FILTER_PATTERN="$2"
                shift 2
                ;;
            --filter=*)
                FILTER_PATTERN="${1#*=}"
                shift
                ;;
            -l|--level)
                LOG_LEVEL="$2"
                shift 2
                ;;
            --level=*)
                LOG_LEVEL="${1#*=}"
                shift
                ;;
            -t|--time-range)
                TIME_RANGE="$2"
                shift 2
                ;;
            --time-range=*)
                TIME_RANGE="${1#*=}"
                shift
                ;;
            --service=*)
                SERVICES+=("${1#*=}")
                shift
                ;;
            --trace-id=*)
                TRACE_ID="${1#*=}"
                shift
                ;;
            --follow)
                FOLLOW="true"
                shift
                ;;
            --output=*)
                OUTPUT_FORMAT="${1#*=}"
                shift
                ;;
            --output-file=*)
                OUTPUT_FILE="${1#*=}"
                shift
                ;;
            --analyze)
                ANALYZE="true"
                shift
                ;;
            --stats)
                STATS="true"
                shift
                ;;
            --errors-only)
                ERRORS_ONLY="true"
                shift
                ;;
            --performance)
                PERFORMANCE="true"
                shift
                ;;
            --highlight=*)
                HIGHLIGHT_PATTERN="${1#*=}"
                shift
                ;;
            --context=*)
                CONTEXT_LINES="${1#*=}"
                shift
                ;;
            --max-lines=*)
                MAX_LINES="${1#*=}"
                shift
                ;;
            --verbose)
                VERBOSE="true"
                shift
                ;;
            --quiet)
                QUIET="true"
                shift
                ;;
            *)
                # ä½œä¸ºæ—¥å¿—æ–‡ä»¶å¤„ç†
                if [ -f "$1" ]; then
                    LOG_FILES+=("$1")
                else
                    log_error "æœªçŸ¥é€‰é¡¹æˆ–æ–‡ä»¶ä¸å­˜åœ¨: $1"
                    exit 1
                fi
                shift
                ;;
        esac
    done
    
    if [ "$QUIET" != "true" ]; then
        show_welcome
    fi
    
    check_dependencies
    
    # å¦‚æœè®¾ç½®äº†è·Ÿè¸ªæ¨¡å¼
    if [ "$FOLLOW" = "true" ]; then
        log_info "å®æ—¶è·Ÿè¸ªæ¨¡å¼ (æŒ‰ Ctrl+C åœæ­¢)"
        
        case "$LOG_SOURCE" in
            "docker")
                docker logs -f $(docker ps --filter "name=order-service\|payment-service\|inventory-service\|jaeger" --format "{{.Names}}" | head -1) 2>&1
                ;;
            *)
                tail -f "${LOG_FILES[0]:-/var/log/syslog}" 2>/dev/null || {
                    log_error "æ— æ³•è·Ÿè¸ªæ—¥å¿—æ–‡ä»¶"
                    exit 1
                }
                ;;
        esac
        exit 0
    fi
    
    # è§£ææ—¶é—´èŒƒå›´
    local start_time end_time
    if [[ "$TIME_RANGE" =~ ^[0-9]+[hmsd]$ ]]; then
        local time_result
        time_result=$(parse_time_range "$TIME_RANGE")
        read start_time end_time <<< "$time_result"
    else
        start_time=""
        end_time=""
    fi
    
    if [ "$VERBOSE" = "true" ]; then
        if [ -n "$start_time" ]; then
            log_info "æ—¶é—´èŒƒå›´: $(date -d @$start_time) - $(date -d @$end_time)"
        fi
    fi
    
    # è·å–æ—¥å¿—æ•°æ®
    local all_logs=""
    
    if [ ${#LOG_FILES[@]} -gt 0 ]; then
        # ä½¿ç”¨æŒ‡å®šçš„æ–‡ä»¶
        LOG_SOURCE="file"
        all_logs=$(get_file_logs "$(printf '%s\n' "${LOG_FILES[@]}")" "$start_time" "$end_time")
    else
        case "$LOG_SOURCE" in
            "docker")
                all_logs=$(get_docker_logs "" "$start_time" "$end_time")
                ;;
            "file")
                all_logs=$(get_file_logs "" "$start_time" "$end_time")
                ;;
            "journald")
                all_logs=$(get_journald_logs "" "$start_time" "$end_time")
                ;;
            "auto")
                # å°è¯•å„ç§æ—¥å¿—æº
                all_logs=$(get_docker_logs "" "$start_time" "$end_time" 2>/dev/null)
                if [ -z "$all_logs" ]; then
                    all_logs=$(get_file_logs "" "$start_time" "$end_time" 2>/dev/null)
                fi
                if [ -z "$all_logs" ]; then
                    all_logs=$(get_journald_logs "" "$start_time" "$end_time" 2>/dev/null)
                fi
                ;;
        esac
    fi
    
    if [ -z "$all_logs" ]; then
        log_error "æœªè·å–åˆ°ä»»ä½•æ—¥å¿—æ•°æ®"
        exit 1
    fi
    
    # åº”ç”¨è¿‡æ»¤å™¨
    local filtered_logs
    filtered_logs=$(apply_filters "$all_logs")
    
    # æ·»åŠ ä¸Šä¸‹æ–‡
    filtered_logs=$(add_context "$filtered_logs" "$CONTEXT_LINES")
    
    # é«˜äº®æ˜¾ç¤º
    filtered_logs=$(highlight_output "$filtered_logs" "$HIGHLIGHT_PATTERN")
    
    # æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
    if [ "$STATS" = "true" ] || [ "$ANALYZE" = "true" ]; then
        analyze_logs "$filtered_logs"
        echo
    fi
    
    # ç”Ÿæˆæœ€ç»ˆè¾“å‡º
    local final_output
    final_output=$(generate_report "$filtered_logs" "$OUTPUT_FORMAT")
    
    # è¾“å‡ºç»“æœ
    if [ -n "$OUTPUT_FILE" ]; then
        echo "$final_output" > "$OUTPUT_FILE"
        log_info "ç»“æœå·²ä¿å­˜åˆ°: $OUTPUT_FILE"
    else
        echo "$final_output"
    fi
    
    if [ "$QUIET" != "true" ]; then
        local line_count
        line_count=$(echo "$filtered_logs" | wc -l)
        log_success "æ—¥å¿—åˆ†æå®Œæˆï¼Œå…±åˆ†æ $line_count è¡Œæ—¥å¿—"
    fi
}

# æ‰§è¡Œä¸»å‡½æ•°
main "$@"