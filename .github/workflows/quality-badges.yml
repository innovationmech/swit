name: Quality Badges

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]
  schedule:
    # ÊØèÂë®Ê£ÄÊü•‰∏ÄÊ¨°Ë¥®ÈáèÁä∂ÊÄÅ
    - cron: '0 6 * * 1'

permissions:
  contents: read
  issues: write
  pull-requests: write

env:
  GO_VERSION: '1.24'

jobs:
  quality-badges:
    name: Generate Quality Badges
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Install dependencies
      run: go mod download

    - name: Install Swagger tools  
      run: |
        if [ ! -f "$HOME/go/bin/swag" ]; then
          make swagger-setup
        fi

    - name: Generate proto code
      run: |
        # Âº∫Âà∂ÁîüÊàê proto ‰ª£Á†Å‰ª•Á°Æ‰øù‰æùËµñÂ≠òÂú®
        make proto

    - name: Generate swagger docs
      run: |
        # Âº∫Âà∂ÁîüÊàê swagger ÊñáÊ°£‰ª•Á°Æ‰øù‰æùËµñÂ≠òÂú®
        make swagger

    - name: Verify generated code
      run: |
        echo "Verifying generated code..."
        
        # ÊòæÁ§∫ÂΩìÂâçÁõÆÂΩïÁªìÊûÑ
        echo "Current directory structure:"
        ls -la
        
        # Ê£ÄÊü•ÂøÖÈúÄÁöÑÁîüÊàêÁõÆÂΩï
        echo "Checking api/gen directory:"
        if [ ! -d "api/gen" ]; then
          echo "‚ùå api/gen directory not found"
          exit 1
        else
          echo "‚úÖ api/gen directory exists"
          find api/gen -name "*.go" | head -10
        fi
        
        echo "Checking docs/generated directories:"
        if [ ! -d "docs/generated/switauth" ]; then
          echo "‚ùå docs/generated/switauth directory not found"
          exit 1
        else
          echo "‚úÖ docs/generated/switauth directory exists"
          ls -la docs/generated/switauth/
        fi
        
        if [ ! -d "docs/generated/switserve" ]; then
          echo "‚ùå docs/generated/switserve directory not found"
          exit 1
        else
          echo "‚úÖ docs/generated/switserve directory exists"
          ls -la docs/generated/switserve/
        fi
        
        # Ê£ÄÊü•ÂÖ≥ÈîÆÊñá‰ª∂
        if [ ! -f "docs/generated/switauth/docs.go" ]; then
          echo "‚ùå docs/generated/switauth/docs.go not found"
          exit 1
        fi
        
        if [ ! -f "docs/generated/switserve/docs.go" ]; then
          echo "‚ùå docs/generated/switserve/docs.go not found"
          exit 1
        fi
        
        echo "‚úÖ All required generated code is present"
        
        # È™åËØÅ go mod ÊòØÂê¶ËÉΩËß£ÊûêÊâÄÊúâÂØºÂÖ•
        echo "Verifying Go module dependencies..."
        go mod tidy
        
        # Â∞ùËØïÁºñËØëÊúâÈóÆÈ¢òÁöÑÂåÖÊù•ËØäÊñ≠ÈóÆÈ¢ò
        echo "Testing compilation of problematic packages:"
        echo "Testing internal/switauth/server/:"
        go build ./internal/switauth/server/ || echo "‚ùå Failed to build switauth/server"
        
        echo "Testing internal/switserve/server/:"
        go build ./internal/switserve/server/ || echo "‚ùå Failed to build switserve/server"
        
        # ‰∏ãËΩΩÊâÄÊúâ‰æùËµñÔºàÂåÖÊã¨ÁîüÊàêÁöÑÂåÖÔºâ
        go mod download

    - name: Install quality tools
      run: |
        go install golang.org/x/tools/cmd/goimports@latest
        go install honnef.co/go/tools/cmd/staticcheck@latest
        go install github.com/securego/gosec/v2/cmd/gosec@latest
        go install golang.org/x/vuln/cmd/govulncheck@latest

    - name: Check code formatting
      id: format
      run: |
        UNFORMATTED=$(gofmt -l . | grep -v "\.pb\.go$" | wc -l)
        if [ "$UNFORMATTED" -eq 0 ]; then
          echo "status=passing" >> $GITHUB_OUTPUT
          echo "message=well formatted" >> $GITHUB_OUTPUT
        else
          echo "status=failing" >> $GITHUB_OUTPUT
          echo "message=${UNFORMATTED} files need formatting" >> $GITHUB_OUTPUT
        fi
        echo "üìè Code formatting check: $UNFORMATTED unformatted files"

    - name: Run static analysis
      id: static
      run: |
        # Ëé∑ÂèñÊâÄÊúâÂåÖÔºåÊéíÈô§Ëá™Âä®ÁîüÊàêÁöÑ‰ª£Á†Å
        PACKAGES=$(go list ./... | grep -v -E '/(api/gen|docs/generated)/')
        
        if [ -z "$PACKAGES" ]; then
          echo "No packages to analyze"
          echo "status=passing" >> $GITHUB_OUTPUT
          echo "message=no packages to check" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "Analyzing packages:"
        echo "$PACKAGES"
        
        # ËøêË°å staticcheckÔºàÊéíÈô§Ëá™Âä®ÁîüÊàêÁöÑ‰ª£Á†ÅÔºâ
        if staticcheck $PACKAGES > staticcheck.txt 2>&1; then
          echo "status=passing" >> $GITHUB_OUTPUT
          echo "message=no issues" >> $GITHUB_OUTPUT
        else
          ISSUES=$(wc -l < staticcheck.txt)
          echo "status=failing" >> $GITHUB_OUTPUT
          echo "message=${ISSUES} issues found" >> $GITHUB_OUTPUT
        fi
        echo "üîç Static analysis completed"

    - name: Security scan
      id: security
      run: |
        # Ëé∑ÂèñÊâÄÊúâÂåÖÔºåÊéíÈô§Ëá™Âä®ÁîüÊàêÁöÑ‰ª£Á†Å
        PACKAGES=$(go list ./... | grep -v -E '/(api/gen|docs/generated)/')
        
        if [ -z "$PACKAGES" ]; then
          echo "No packages to scan"
          echo "status=passing" >> $GITHUB_OUTPUT
          echo "message=no packages to check" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "Scanning packages:"
        echo "$PACKAGES"
        
        # ËøêË°å gosecÔºàÊéíÈô§Ëá™Âä®ÁîüÊàêÁöÑ‰ª£Á†ÅÔºâ
        if gosec $PACKAGES > gosec.txt 2>&1; then
          echo "status=passing" >> $GITHUB_OUTPUT
          echo "message=no vulnerabilities" >> $GITHUB_OUTPUT
        else
          VULNS=$(grep -c "Severity:" gosec.txt || echo "0")
          echo "status=failing" >> $GITHUB_OUTPUT
          echo "message=${VULNS} potential issues" >> $GITHUB_OUTPUT
        fi
        echo "üîê Security scan completed"

    - name: Vulnerability check
      id: vuln
      run: |
        # Ëé∑ÂèñÊâÄÊúâÂåÖÔºåÊéíÈô§Ëá™Âä®ÁîüÊàêÁöÑ‰ª£Á†Å
        PACKAGES=$(go list ./... | grep -v -E '/(api/gen|docs/generated)/')
        
        if [ -z "$PACKAGES" ]; then
          echo "No packages to check"
          echo "status=passing" >> $GITHUB_OUTPUT
          echo "message=no packages to check" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "Checking packages:"
        echo "$PACKAGES"
        
        # ËøêË°å govulncheckÔºàÊéíÈô§Ëá™Âä®ÁîüÊàêÁöÑ‰ª£Á†ÅÔºâ
        if govulncheck $PACKAGES > vuln.txt 2>&1; then
          echo "status=passing" >> $GITHUB_OUTPUT
          echo "message=no known vulnerabilities" >> $GITHUB_OUTPUT
        else
          echo "status=failing" >> $GITHUB_OUTPUT
          echo "message=vulnerabilities found" >> $GITHUB_OUTPUT
        fi
        echo "üö® Vulnerability check completed"

    - name: Test coverage check
      id: coverage
      run: |
        # Ëé∑ÂèñÊâÄÊúâÂåÖÔºåÊéíÈô§Ëá™Âä®ÁîüÊàêÁöÑ‰ª£Á†Å
        PACKAGES=$(go list ./... | grep -v -E '/(api/gen|docs/generated)/')
        
        if [ -z "$PACKAGES" ]; then
          echo "No packages to test"
          echo "status=needs_improvement" >> $GITHUB_OUTPUT
          echo "color=red" >> $GITHUB_OUTPUT
          echo "coverage=0" >> $GITHUB_OUTPUT
          echo "üìä Test coverage: 0% (no packages to test)"
          exit 0
        fi
        
        echo "Testing packages:"
        echo "$PACKAGES"
        
        # ËøêË°åÊµãËØïÂπ∂Ê£ÄÊü•Ë¶ÜÁõñÁéáÔºàÊéíÈô§Ëá™Âä®ÁîüÊàêÁöÑ‰ª£Á†ÅÔºâ
        go test -coverprofile=coverage.out $PACKAGES > test.txt 2>&1
        COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print substr($3, 1, length($3)-1)}')
        
        # ËΩ¨Êç¢‰∏∫Êï¥Êï∞ËøõË°åÊØîËæÉÔºàÂéªÊéâÂ∞èÊï∞ÁÇπÔºâ
        COVERAGE_INT=$(echo "$COVERAGE" | cut -d. -f1)
        
        if [ "$COVERAGE_INT" -ge 80 ]; then
          echo "status=excellent" >> $GITHUB_OUTPUT
          echo "color=brightgreen" >> $GITHUB_OUTPUT
        elif [ "$COVERAGE_INT" -ge 60 ]; then
          echo "status=good" >> $GITHUB_OUTPUT
          echo "color=yellow" >> $GITHUB_OUTPUT
        else
          echo "status=needs_improvement" >> $GITHUB_OUTPUT
          echo "color=red" >> $GITHUB_OUTPUT
        fi
        echo "coverage=${COVERAGE}" >> $GITHUB_OUTPUT
        echo "üìä Test coverage: ${COVERAGE}%"

    - name: Calculate overall quality score
      id: quality
      run: |
        SCORE=0
        TOTAL=5
        
        # Ê†ºÂºèÊ£ÄÊü• (20%)
        if [ "${{ steps.format.outputs.status }}" = "passing" ]; then
          SCORE=$((SCORE + 1))
        fi
        
        # ÈùôÊÄÅÂàÜÊûê (20%)
        if [ "${{ steps.static.outputs.status }}" = "passing" ]; then
          SCORE=$((SCORE + 1))
        fi
        
        # ÂÆâÂÖ®Êâ´Êèè (20%)
        if [ "${{ steps.security.outputs.status }}" = "passing" ]; then
          SCORE=$((SCORE + 1))
        fi
        
        # ÊºèÊ¥ûÊ£ÄÊü• (20%)
        if [ "${{ steps.vuln.outputs.status }}" = "passing" ]; then
          SCORE=$((SCORE + 1))
        fi
        
        # ÊµãËØïË¶ÜÁõñÁéá (20%)
        if [ "${{ steps.coverage.outputs.status }}" != "needs_improvement" ]; then
          SCORE=$((SCORE + 1))
        fi
        
        PERCENTAGE=$((SCORE * 100 / TOTAL))
        
        if [ $PERCENTAGE -ge 80 ]; then
          GRADE="A"
          COLOR="brightgreen"
        elif [ $PERCENTAGE -ge 60 ]; then
          GRADE="B"
          COLOR="yellow"
        elif [ $PERCENTAGE -ge 40 ]; then
          GRADE="C"
          COLOR="orange"
        else
          GRADE="D"
          COLOR="red"
        fi
        
        echo "score=${PERCENTAGE}" >> $GITHUB_OUTPUT
        echo "grade=${GRADE}" >> $GITHUB_OUTPUT
        echo "color=${COLOR}" >> $GITHUB_OUTPUT
        echo "üèÜ Overall quality score: ${PERCENTAGE}% (Grade: ${GRADE})"

    - name: Generate quality report
      run: |
        cat > QUALITY_REPORT.md << EOF
        # üìä Code Quality Report
        
        Generated on: $(date)
        
        ## üèÜ Overall Score: ${{ steps.quality.outputs.score }}% (Grade: ${{ steps.quality.outputs.grade }})
        
        ### üìã Detailed Results
        
        | Check | Status | Details |
        |-------|--------|---------|
        | üìè Code Formatting | ${{ steps.format.outputs.status }} | ${{ steps.format.outputs.message }} |
        | üîç Static Analysis | ${{ steps.static.outputs.status }} | ${{ steps.static.outputs.message }} |
        | üîê Security Scan | ${{ steps.security.outputs.status }} | ${{ steps.security.outputs.message }} |
        | üö® Vulnerability Check | ${{ steps.vuln.outputs.status }} | ${{ steps.vuln.outputs.message }} |
        | üìä Test Coverage | ${{ steps.coverage.outputs.status }} | ${{ steps.coverage.outputs.coverage }}% |
        
        ### üè∑Ô∏è Quality Badges
        
        Copy these badges to your README.md:
        
        \`\`\`markdown
        ![Code Quality](https://img.shields.io/badge/quality-${{ steps.quality.outputs.grade }}-${{ steps.quality.outputs.color }})
        ![Code Formatting](https://img.shields.io/badge/formatting-${{ steps.format.outputs.status }}-$([ "${{ steps.format.outputs.status }}" = "passing" ] && echo "brightgreen" || echo "red"))
        ![Security](https://img.shields.io/badge/security-${{ steps.security.outputs.status }}-$([ "${{ steps.security.outputs.status }}" = "passing" ] && echo "brightgreen" || echo "red"))
        ![Coverage](https://img.shields.io/badge/coverage-${{ steps.coverage.outputs.coverage }}%25-${{ steps.coverage.outputs.color }})
        \`\`\`
        EOF
        
        echo "üìã Generated quality report"

    - name: Upload quality report
      uses: actions/upload-artifact@v4
      with:
        name: quality-report
        path: |
          QUALITY_REPORT.md
          staticcheck.txt
          gosec.txt
          vuln.txt
          test.txt
          coverage.out
        retention-days: 30

    - name: Comment on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const score = '${{ steps.quality.outputs.score }}';
          const grade = '${{ steps.quality.outputs.grade }}';
          const body = `## üìä Code Quality Report
          
          **Overall Score**: ${score}% (Grade: **${grade}**)
          
          ### Results Summary
          - üìè **Code Formatting**: ${{ steps.format.outputs.status }} (${{ steps.format.outputs.message }})
          - üîç **Static Analysis**: ${{ steps.static.outputs.status }} (${{ steps.static.outputs.message }})  
          - üîê **Security Scan**: ${{ steps.security.outputs.status }} (${{ steps.security.outputs.message }})
          - üö® **Vulnerability Check**: ${{ steps.vuln.outputs.status }} (${{ steps.vuln.outputs.message }})
          - üìä **Test Coverage**: ${{ steps.coverage.outputs.status }} (${{ steps.coverage.outputs.coverage }}%)
          
          ${grade === 'A' ? 'üéâ Excellent code quality!' : grade === 'B' ? 'üëç Good code quality!' : '‚ö†Ô∏è Code quality could be improved.'}
          
          ---
          *Quality report generated by GitHub Actions*`;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: body
          });
