// Copyright Â© 2025 jackelyj <dreamerlyj@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

// Package vulnerability provides vulnerability checking capabilities using the OSV database.
package vulnerability

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"
)

const (
	// DefaultOSVAPIURL is the default URL for the OSV.dev API.
	DefaultOSVAPIURL = "https://api.osv.dev"
	// DefaultTimeout is the default timeout for API requests.
	DefaultTimeout = 30 * time.Second
)

// OSVDatabase provides access to the OSV vulnerability database.
type OSVDatabase struct {
	apiURL     string
	httpClient *http.Client
	cacheDir   string
	lastUpdate time.Time
}

// DatabaseConfig represents the configuration for the vulnerability database.
type DatabaseConfig struct {
	// APIURL is the base URL for the OSV API (default: https://api.osv.dev).
	APIURL string `yaml:"api_url" json:"api_url"`
	// Timeout is the timeout for API requests.
	Timeout time.Duration `yaml:"timeout" json:"timeout"`
	// CacheDir is the directory for caching vulnerability data (optional).
	CacheDir string `yaml:"cache_dir" json:"cache_dir"`
	// UpdateInterval is how often to update the cached database.
	UpdateInterval time.Duration `yaml:"update_interval" json:"update_interval"`
}

// DefaultDatabaseConfig returns the default database configuration.
func DefaultDatabaseConfig() *DatabaseConfig {
	return &DatabaseConfig{
		APIURL:         DefaultOSVAPIURL,
		Timeout:        DefaultTimeout,
		CacheDir:       "",
		UpdateInterval: 24 * time.Hour,
	}
}

// NewOSVDatabase creates a new OSV database client.
func NewOSVDatabase(config *DatabaseConfig) (*OSVDatabase, error) {
	if config == nil {
		config = DefaultDatabaseConfig()
	}

	if config.APIURL == "" {
		config.APIURL = DefaultOSVAPIURL
	}

	if config.Timeout == 0 {
		config.Timeout = DefaultTimeout
	}

	return &OSVDatabase{
		apiURL: config.APIURL,
		httpClient: &http.Client{
			Timeout: config.Timeout,
		},
		cacheDir:   config.CacheDir,
		lastUpdate: time.Now(),
	}, nil
}

// QueryRequest represents a request to query the OSV database.
type QueryRequest struct {
	// Package information to query.
	Package *PackageInfo `json:"package,omitempty"`
	// Version of the package to query.
	Version string `json:"version,omitempty"`
	// Commit hash to query (for Git-based packages).
	Commit string `json:"commit,omitempty"`
}

// PackageInfo represents package identification information.
type PackageInfo struct {
	// Name of the package.
	Name string `json:"name"`
	// Ecosystem the package belongs to (e.g., "Go", "npm", "PyPI").
	Ecosystem string `json:"ecosystem"`
}

// QueryResponse represents the response from a vulnerability query.
type QueryResponse struct {
	// Vulnerabilities found for the query.
	Vulns []Vulnerability `json:"vulns"`
}

// Vulnerability represents a vulnerability record from OSV.
type Vulnerability struct {
	// ID is the unique identifier for the vulnerability.
	ID string `json:"id"`
	// Summary is a brief description of the vulnerability.
	Summary string `json:"summary"`
	// Details provides detailed information about the vulnerability.
	Details string `json:"details"`
	// Aliases are alternative identifiers for this vulnerability.
	Aliases []string `json:"aliases,omitempty"`
	// Modified is when the vulnerability was last modified.
	Modified string `json:"modified"`
	// Published is when the vulnerability was first published.
	Published string `json:"published"`
	// Withdrawn is when the vulnerability was withdrawn (if applicable).
	Withdrawn string `json:"withdrawn,omitempty"`
	// References are external references related to the vulnerability.
	References []Reference `json:"references,omitempty"`
	// Severity information for the vulnerability.
	Severity []SeverityInfo `json:"severity,omitempty"`
	// Affected lists the affected package versions.
	Affected []AffectedPackage `json:"affected,omitempty"`
	// DatabaseSpecific contains database-specific metadata.
	DatabaseSpecific map[string]interface{} `json:"database_specific,omitempty"`
}

// Reference represents an external reference for a vulnerability.
type Reference struct {
	// Type of the reference (e.g., "WEB", "ADVISORY").
	Type string `json:"type"`
	// URL of the reference.
	URL string `json:"url"`
}

// SeverityInfo represents severity information for a vulnerability.
type SeverityInfo struct {
	// Type of severity rating (e.g., "CVSS_V3").
	Type string `json:"type"`
	// Score is the severity score.
	Score string `json:"score"`
}

// AffectedPackage represents information about an affected package.
type AffectedPackage struct {
	// Package information.
	Package PackageInfo `json:"package"`
	// Ranges specifies the affected version ranges.
	Ranges []VersionRange `json:"ranges,omitempty"`
	// Versions is an explicit list of affected versions.
	Versions []string `json:"versions,omitempty"`
	// EcosystemSpecific contains ecosystem-specific metadata.
	EcosystemSpecific map[string]interface{} `json:"ecosystem_specific,omitempty"`
	// DatabaseSpecific contains database-specific metadata.
	DatabaseSpecific map[string]interface{} `json:"database_specific,omitempty"`
}

// VersionRange represents a range of affected versions.
type VersionRange struct {
	// Type of version range (e.g., "SEMVER", "GIT").
	Type string `json:"type"`
	// Repo is the repository URL (for GIT type).
	Repo string `json:"repo,omitempty"`
	// Events defines version range boundaries.
	Events []VersionEvent `json:"events"`
}

// VersionEvent represents a version range boundary event.
type VersionEvent struct {
	// Introduced is the version where the vulnerability was introduced.
	Introduced string `json:"introduced,omitempty"`
	// Fixed is the version where the vulnerability was fixed.
	Fixed string `json:"fixed,omitempty"`
	// LastAffected is the last affected version.
	LastAffected string `json:"last_affected,omitempty"`
	// Limit is the upper limit of the range.
	Limit string `json:"limit,omitempty"`
}

// BatchQueryRequest represents a batch query request.
type BatchQueryRequest struct {
	// Queries is a list of individual queries.
	Queries []QueryRequest `json:"queries"`
}

// BatchQueryResponse represents the response from a batch query.
type BatchQueryResponse struct {
	// Results contains the results for each query.
	Results []QueryResponse `json:"results"`
}

// Query queries the OSV database for vulnerabilities affecting a specific package version.
func (db *OSVDatabase) Query(ctx context.Context, req *QueryRequest) (*QueryResponse, error) {
	if req == nil {
		return nil, fmt.Errorf("query request cannot be nil")
	}

	// Marshal request to JSON
	reqBody, err := json.Marshal(req)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", db.apiURL+"/v1/query", bytes.NewBuffer(reqBody))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}
	httpReq.Header.Set("Content-Type", "application/json")

	// Execute request
	resp, err := db.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Check response status
	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
	}

	// Parse response
	var queryResp QueryResponse
	if err := json.NewDecoder(resp.Body).Decode(&queryResp); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	return &queryResp, nil
}

// BatchQuery performs multiple queries in a single request.
func (db *OSVDatabase) BatchQuery(ctx context.Context, queries []QueryRequest) (*BatchQueryResponse, error) {
	if len(queries) == 0 {
		return &BatchQueryResponse{Results: []QueryResponse{}}, nil
	}

	// Marshal request to JSON
	batchReq := BatchQueryRequest{Queries: queries}
	reqBody, err := json.Marshal(batchReq)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal batch request: %w", err)
	}

	// Create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, "POST", db.apiURL+"/v1/querybatch", bytes.NewBuffer(reqBody))
	if err != nil {
		return nil, fmt.Errorf("failed to create batch request: %w", err)
	}
	httpReq.Header.Set("Content-Type", "application/json")

	// Execute request
	resp, err := db.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute batch request: %w", err)
	}
	defer resp.Body.Close()

	// Check response status
	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
	}

	// Parse response
	var batchResp BatchQueryResponse
	if err := json.NewDecoder(resp.Body).Decode(&batchResp); err != nil {
		return nil, fmt.Errorf("failed to decode batch response: %w", err)
	}

	return &batchResp, nil
}

// GetVulnerability retrieves details for a specific vulnerability by ID.
func (db *OSVDatabase) GetVulnerability(ctx context.Context, vulnID string) (*Vulnerability, error) {
	if vulnID == "" {
		return nil, fmt.Errorf("vulnerability ID cannot be empty")
	}

	// Create HTTP request
	url := fmt.Sprintf("%s/v1/vulns/%s", db.apiURL, vulnID)
	httpReq, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Execute request
	resp, err := db.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Check response status
	if resp.StatusCode == http.StatusNotFound {
		return nil, fmt.Errorf("vulnerability %s not found", vulnID)
	}
	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
	}

	// Parse response
	var vuln Vulnerability
	if err := json.NewDecoder(resp.Body).Decode(&vuln); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	return &vuln, nil
}

// UpdateDatabase updates the local vulnerability database cache.
func (db *OSVDatabase) UpdateDatabase(ctx context.Context) error {
	// Check if update is needed
	if time.Since(db.lastUpdate) < 1*time.Hour {
		return nil // Skip update if too recent
	}

	// Note: Full database synchronization is not implemented in this basic version
	// In production, you would download and cache the full vulnerability database
	// For now, we just mark the last update time
	db.lastUpdate = time.Now()

	return nil
}

// NeedsUpdate checks if the database cache needs to be updated.
func (db *OSVDatabase) NeedsUpdate(updateInterval time.Duration) bool {
	return time.Since(db.lastUpdate) > updateInterval
}

// GetLastUpdateTime returns when the database was last updated.
func (db *OSVDatabase) GetLastUpdateTime() time.Time {
	return db.lastUpdate
}

