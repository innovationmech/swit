// Copyright Â© 2025 jackelyj <dreamerlyj@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

package vulnerability

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"time"

	"go.uber.org/zap"
	"golang.org/x/mod/modfile"
)

// VulnerabilityChecker provides vulnerability checking capabilities.
type VulnerabilityChecker struct {
	database *OSVDatabase
	config   *CheckerConfig
	logger   *zap.Logger
}

// CheckerConfig represents the configuration for the vulnerability checker.
type CheckerConfig struct {
	// Database configuration.
	Database *DatabaseConfig `yaml:"database" json:"database"`
	// ModulePath is the path to the Go module to check (default: current directory).
	ModulePath string `yaml:"module_path" json:"module_path"`
	// FailOnHigh determines if the checker should fail on high severity vulnerabilities.
	FailOnHigh bool `yaml:"fail_on_high" json:"fail_on_high"`
	// FailOnMedium determines if the checker should fail on medium severity vulnerabilities.
	FailOnMedium bool `yaml:"fail_on_medium" json:"fail_on_medium"`
	// FailOnCritical determines if the checker should fail on critical severity vulnerabilities.
	FailOnCritical bool `yaml:"fail_on_critical" json:"fail_on_critical"`
	// Timeout is the maximum duration for checking operations.
	Timeout time.Duration `yaml:"timeout" json:"timeout"`
	// UpdateInterval is how often to update the vulnerability database.
	UpdateInterval time.Duration `yaml:"update_interval" json:"update_interval"`
	// ReportPath is where to save the vulnerability report (optional).
	ReportPath string `yaml:"report_path" json:"report_path"`
	// NotifyOnVulnerabilities enables notifications when vulnerabilities are found.
	NotifyOnVulnerabilities bool `yaml:"notify_on_vulnerabilities" json:"notify_on_vulnerabilities"`
}

// DefaultCheckerConfig returns the default checker configuration.
func DefaultCheckerConfig() *CheckerConfig {
	return &CheckerConfig{
		Database:                DefaultDatabaseConfig(),
		ModulePath:              ".",
		FailOnHigh:              true,
		FailOnMedium:            false,
		FailOnCritical:          true,
		Timeout:                 5 * time.Minute,
		UpdateInterval:          24 * time.Hour,
		ReportPath:              "_output/security/vulnerability-report.json",
		NotifyOnVulnerabilities: false,
	}
}

// NewVulnerabilityChecker creates a new vulnerability checker.
func NewVulnerabilityChecker(config *CheckerConfig, logger *zap.Logger) (*VulnerabilityChecker, error) {
	if config == nil {
		config = DefaultCheckerConfig()
	}

	if logger == nil {
		logger = zap.NewNop()
	}

	// Create OSV database client
	database, err := NewOSVDatabase(config.Database)
	if err != nil {
		return nil, fmt.Errorf("failed to create OSV database client: %w", err)
	}

	return &VulnerabilityChecker{
		database: database,
		config:   config,
		logger:   logger,
	}, nil
}

// CheckResult represents the result of a vulnerability check.
type CheckResult struct {
	// Timestamp when the check was performed.
	Timestamp time.Time `json:"timestamp"`
	// Duration of the check.
	Duration time.Duration `json:"duration"`
	// ModulePath is the path to the module that was checked.
	ModulePath string `json:"module_path"`
	// Vulnerabilities found.
	Vulnerabilities []VulnerabilityFinding `json:"vulnerabilities"`
	// Summary provides aggregated statistics.
	Summary CheckSummary `json:"summary"`
	// Error contains any error that occurred during checking (optional).
	Error string `json:"error,omitempty"`
}

// VulnerabilityFinding represents a vulnerability found in a dependency.
type VulnerabilityFinding struct {
	// VulnerabilityID is the OSV vulnerability ID.
	VulnerabilityID string `json:"vulnerability_id"`
	// PackageName is the name of the affected package.
	PackageName string `json:"package_name"`
	// InstalledVersion is the currently installed version.
	InstalledVersion string `json:"installed_version"`
	// FixedVersion is the version with the fix (if available).
	FixedVersion string `json:"fixed_version,omitempty"`
	// Severity is the severity level of the vulnerability.
	Severity string `json:"severity"`
	// CVSS is the CVSS score (if available).
	CVSS float64 `json:"cvss,omitempty"`
	// Summary is a brief description of the vulnerability.
	Summary string `json:"summary"`
	// Details provides detailed information.
	Details string `json:"details"`
	// References are external references.
	References []string `json:"references,omitempty"`
	// Aliases are alternative identifiers.
	Aliases []string `json:"aliases,omitempty"`
}

// CheckSummary provides aggregated statistics about the check.
type CheckSummary struct {
	// TotalDependencies is the total number of dependencies checked.
	TotalDependencies int `json:"total_dependencies"`
	// VulnerableCount is the count of dependencies with vulnerabilities.
	VulnerableCount int `json:"vulnerable_count"`
	// TotalVulnerabilities is the total number of vulnerabilities found.
	TotalVulnerabilities int `json:"total_vulnerabilities"`
	// CriticalCount is the count of critical severity vulnerabilities.
	CriticalCount int `json:"critical_count"`
	// HighCount is the count of high severity vulnerabilities.
	HighCount int `json:"high_count"`
	// MediumCount is the count of medium severity vulnerabilities.
	MediumCount int `json:"medium_count"`
	// LowCount is the count of low severity vulnerabilities.
	LowCount int `json:"low_count"`
}

// Check performs a vulnerability check on the configured module.
func (c *VulnerabilityChecker) Check(ctx context.Context) (*CheckResult, error) {
	startTime := time.Now()

	result := &CheckResult{
		Timestamp:       startTime,
		ModulePath:      c.config.ModulePath,
		Vulnerabilities: make([]VulnerabilityFinding, 0),
		Summary:         CheckSummary{},
	}

	// Create context with timeout
	checkCtx, cancel := context.WithTimeout(ctx, c.config.Timeout)
	defer cancel()

	// Update database if needed
	if c.database.NeedsUpdate(c.config.UpdateInterval) {
		c.logger.Info("Updating vulnerability database")
		if err := c.database.UpdateDatabase(checkCtx); err != nil {
			c.logger.Warn("Failed to update vulnerability database", zap.Error(err))
		}
	}

	// Parse go.mod file
	dependencies, err := c.parseDependencies()
	if err != nil {
		result.Error = fmt.Sprintf("failed to parse dependencies: %v", err)
		result.Duration = time.Since(startTime)
		return result, err
	}

	result.Summary.TotalDependencies = len(dependencies)
	c.logger.Info("Checking dependencies for vulnerabilities",
		zap.Int("total_dependencies", len(dependencies)))

	// Check each dependency for vulnerabilities
	queries := make([]QueryRequest, 0, len(dependencies))
	for name, version := range dependencies {
		queries = append(queries, QueryRequest{
			Package: &PackageInfo{
				Name:      name,
				Ecosystem: "Go",
			},
			Version: version,
		})
	}

	// Batch query for all dependencies
	batchResp, err := c.database.BatchQuery(checkCtx, queries)
	if err != nil {
		result.Error = fmt.Sprintf("failed to query vulnerabilities: %v", err)
		result.Duration = time.Since(startTime)
		return result, err
	}

	// Process results
	packageIndex := 0
	for _, queryResp := range batchResp.Results {
		if len(queryResp.Vulns) > 0 {
			result.Summary.VulnerableCount++

			packageName := queries[packageIndex].Package.Name
			packageVersion := queries[packageIndex].Version

			for _, vuln := range queryResp.Vulns {
				finding := c.convertToFinding(packageName, packageVersion, &vuln)
				result.Vulnerabilities = append(result.Vulnerabilities, finding)
				result.Summary.TotalVulnerabilities++

				// Update severity counts
				switch finding.Severity {
				case "critical":
					result.Summary.CriticalCount++
				case "high":
					result.Summary.HighCount++
				case "medium":
					result.Summary.MediumCount++
				case "low":
					result.Summary.LowCount++
				}
			}
		}
		packageIndex++
	}

	result.Duration = time.Since(startTime)

	c.logger.Info("Vulnerability check completed",
		zap.Int("total_vulnerabilities", result.Summary.TotalVulnerabilities),
		zap.Int("critical", result.Summary.CriticalCount),
		zap.Int("high", result.Summary.HighCount),
		zap.Int("medium", result.Summary.MediumCount),
		zap.Int("low", result.Summary.LowCount),
		zap.Duration("duration", result.Duration))

	// Generate report if configured
	if c.config.ReportPath != "" {
		if err := c.saveReport(result); err != nil {
			c.logger.Warn("Failed to save vulnerability report", zap.Error(err))
		}
	}

	return result, nil
}

// parseDependencies parses the full dependency graph including transitive dependencies.
// It uses 'go list -m all' to get the complete list of all modules in the build,
// which includes both direct and indirect dependencies.
func (c *VulnerabilityChecker) parseDependencies() (map[string]string, error) {
	dependencies := make(map[string]string)

	// Use 'go list -m all' to get the complete dependency graph
	// This includes both direct and indirect (transitive) dependencies
	cmd := exec.CommandContext(context.Background(), "go", "list", "-m", "-json", "all")
	cmd.Dir = c.config.ModulePath

	output, err := cmd.Output()
	if err != nil {
		// Fallback to parsing go.mod if 'go list' fails
		c.logger.Warn("Failed to run 'go list -m all', falling back to go.mod parsing", zap.Error(err))
		return c.parseGoModFile()
	}

	// Parse JSON output - 'go list -m -json all' outputs one JSON object per line
	decoder := json.NewDecoder(bytes.NewReader(output))
	for decoder.More() {
		var module struct {
			Path    string `json:"Path"`
			Version string `json:"Version"`
			Main    bool   `json:"Main"`
		}

		if err := decoder.Decode(&module); err != nil {
			c.logger.Warn("Failed to decode module info", zap.Error(err))
			continue
		}

		// Skip the main module itself
		if module.Main {
			continue
		}

		// Skip modules without a version (shouldn't happen, but be safe)
		if module.Version == "" {
			continue
		}

		dependencies[module.Path] = module.Version
	}

	if len(dependencies) == 0 {
		c.logger.Warn("No dependencies found via 'go list', falling back to go.mod parsing")
		return c.parseGoModFile()
	}

	c.logger.Info("Parsed complete dependency graph",
		zap.Int("total_dependencies", len(dependencies)),
		zap.String("method", "go list -m all"))

	return dependencies, nil
}

// parseGoModFile is a fallback method that parses go.mod directly.
// It only returns direct dependencies and is used when 'go list' fails.
func (c *VulnerabilityChecker) parseGoModFile() (map[string]string, error) {
	goModPath := filepath.Join(c.config.ModulePath, "go.mod")
	data, err := os.ReadFile(goModPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read go.mod: %w", err)
	}

	modFile, err := modfile.Parse(goModPath, data, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to parse go.mod: %w", err)
	}

	// Extract all dependencies (including indirect ones as fallback)
	dependencies := make(map[string]string)
	for _, req := range modFile.Require {
		dependencies[req.Mod.Path] = req.Mod.Version
	}

	c.logger.Info("Parsed dependencies from go.mod (fallback)",
		zap.Int("total_dependencies", len(dependencies)),
		zap.String("method", "go.mod parsing"))

	return dependencies, nil
}

// convertToFinding converts an OSV vulnerability to a VulnerabilityFinding.
func (c *VulnerabilityChecker) convertToFinding(packageName, installedVersion string, vuln *Vulnerability) VulnerabilityFinding {
	finding := VulnerabilityFinding{
		VulnerabilityID:  vuln.ID,
		PackageName:      packageName,
		InstalledVersion: installedVersion,
		Summary:          vuln.Summary,
		Details:          vuln.Details,
		Aliases:          vuln.Aliases,
	}

	// Extract references
	for _, ref := range vuln.References {
		finding.References = append(finding.References, ref.URL)
	}

	// Extract severity and CVSS
	severity, cvss := c.extractSeverity(vuln)
	finding.Severity = severity
	finding.CVSS = cvss

	// Extract fixed version
	for _, affected := range vuln.Affected {
		if affected.Package.Name == packageName {
			for _, versionRange := range affected.Ranges {
				for _, event := range versionRange.Events {
					if event.Fixed != "" {
						finding.FixedVersion = event.Fixed
						break
					}
				}
				if finding.FixedVersion != "" {
					break
				}
			}
		}
	}

	return finding
}

// extractSeverity extracts severity level and CVSS score from a vulnerability.
func (c *VulnerabilityChecker) extractSeverity(vuln *Vulnerability) (string, float64) {
	var cvss float64
	severity := "unknown"

	// Look for CVSS score
	for _, sev := range vuln.Severity {
		if sev.Type == "CVSS_V3" {
			cvss = c.parseCVSS(sev.Score)
			break
		}
	}

	// Map CVSS to severity
	switch {
	case cvss >= 9.0:
		severity = "critical"
	case cvss >= 7.0:
		severity = "high"
	case cvss >= 4.0:
		severity = "medium"
	case cvss > 0:
		severity = "low"
	default:
		severity = "info"
	}

	return severity, cvss
}

// parseCVSS parses a CVSS score string.
func (c *VulnerabilityChecker) parseCVSS(scoreStr string) float64 {
	// CVSS score format: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
	// This is a simplified implementation
	// In production, use a proper CVSS calculator library

	// Common mappings for quick assessment
	if len(scoreStr) > 0 && scoreStr[0] >= '0' && scoreStr[0] <= '9' {
		// If it starts with a digit, try to parse it directly
		var score float64
		fmt.Sscanf(scoreStr, "%f", &score)
		return score
	}

	// Default parsing based on impact indicators
	criticalImpact := 0
	if len(scoreStr) > 0 {
		// Count high impact indicators
		for i := 0; i < len(scoreStr)-1; i++ {
			if scoreStr[i] == ':' && scoreStr[i+1] == 'H' {
				criticalImpact++
			}
		}
	}

	switch criticalImpact {
	case 3:
		return 9.0
	case 2:
		return 7.5
	case 1:
		return 5.0
	default:
		return 3.0
	}
}

// ShouldFail determines if the check result should cause a failure.
func (c *VulnerabilityChecker) ShouldFail(result *CheckResult) bool {
	if c.config.FailOnCritical && result.Summary.CriticalCount > 0 {
		return true
	}
	if c.config.FailOnHigh && result.Summary.HighCount > 0 {
		return true
	}
	if c.config.FailOnMedium && result.Summary.MediumCount > 0 {
		return true
	}
	return false
}

// saveReport saves the vulnerability report to a file.
func (c *VulnerabilityChecker) saveReport(result *CheckResult) error {
	// Create output directory if needed
	reportDir := filepath.Dir(c.config.ReportPath)
	if err := os.MkdirAll(reportDir, 0755); err != nil {
		return fmt.Errorf("failed to create report directory: %w", err)
	}

	// Generate report in JSON format
	report := &VulnerabilityReport{
		GeneratedAt:     result.Timestamp,
		ModulePath:      result.ModulePath,
		CheckDuration:   result.Duration,
		Summary:         result.Summary,
		Vulnerabilities: result.Vulnerabilities,
	}

	// Write report to file
	file, err := os.Create(c.config.ReportPath)
	if err != nil {
		return fmt.Errorf("failed to create report file: %w", err)
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	if err := encoder.Encode(report); err != nil {
		return fmt.Errorf("failed to write report: %w", err)
	}

	c.logger.Info("Vulnerability report saved", zap.String("path", c.config.ReportPath))
	return nil
}

// VulnerabilityReport represents a saved vulnerability report.
type VulnerabilityReport struct {
	GeneratedAt     time.Time              `json:"generated_at"`
	ModulePath      string                 `json:"module_path"`
	CheckDuration   time.Duration          `json:"check_duration"`
	Summary         CheckSummary           `json:"summary"`
	Vulnerabilities []VulnerabilityFinding `json:"vulnerabilities"`
}
