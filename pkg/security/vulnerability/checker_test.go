// Copyright Â© 2025 jackelyj <dreamerlyj@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

package vulnerability

import (
	"context"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.uber.org/zap/zaptest"
)

func TestNewVulnerabilityChecker(t *testing.T) {
	tests := []struct {
		name    string
		config  *CheckerConfig
		wantErr bool
	}{
		{
			name:    "with default config",
			config:  nil,
			wantErr: false,
		},
		{
			name:    "with custom config",
			config:  DefaultCheckerConfig(),
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			logger := zaptest.NewLogger(t)
			checker, err := NewVulnerabilityChecker(tt.config, logger)

			if tt.wantErr {
				assert.Error(t, err)
				assert.Nil(t, checker)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, checker)
				assert.NotNil(t, checker.database)
				assert.NotNil(t, checker.config)
				assert.NotNil(t, checker.logger)
			}
		})
	}
}

func TestDefaultCheckerConfig(t *testing.T) {
	config := DefaultCheckerConfig()

	assert.NotNil(t, config)
	assert.NotNil(t, config.Database)
	assert.Equal(t, ".", config.ModulePath)
	assert.True(t, config.FailOnHigh)
	assert.False(t, config.FailOnMedium)
	assert.True(t, config.FailOnCritical)
	assert.Equal(t, 5*time.Minute, config.Timeout)
	assert.Equal(t, 24*time.Hour, config.UpdateInterval)
	assert.False(t, config.NotifyOnVulnerabilities)
}

func TestVulnerabilityChecker_ParseDependencies(t *testing.T) {
	// Create a temporary directory with a test go.mod file
	tmpDir := t.TempDir()
	goModPath := filepath.Join(tmpDir, "go.mod")

	goModContent := `module example.com/test

go 1.23

require (
	github.com/gin-gonic/gin v1.9.1
	github.com/stretchr/testify v1.8.4
	go.uber.org/zap v1.26.0
)

require (
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
)
`
	err := os.WriteFile(goModPath, []byte(goModContent), 0644)
	require.NoError(t, err)

	config := &CheckerConfig{
		Database:   DefaultDatabaseConfig(),
		ModulePath: tmpDir,
	}

	logger := zaptest.NewLogger(t)
	checker, err := NewVulnerabilityChecker(config, logger)
	require.NoError(t, err)

	deps, err := checker.parseDependencies()
	require.NoError(t, err)

	// Note: The actual behavior depends on whether 'go list' is available
	// If 'go list -m all' works, it would include all transitive dependencies
	// If it falls back to go.mod parsing, it includes all dependencies from go.mod
	assert.NotEmpty(t, deps)
	
	// At minimum, should contain the direct dependencies
	assert.Contains(t, deps, "github.com/gin-gonic/gin")
	assert.Contains(t, deps, "github.com/stretchr/testify")
	assert.Contains(t, deps, "go.uber.org/zap")
}

func TestVulnerabilityChecker_ParseGoModFile(t *testing.T) {
	// Test the fallback go.mod parsing method
	tmpDir := t.TempDir()
	goModPath := filepath.Join(tmpDir, "go.mod")

	goModContent := `module example.com/test

go 1.23

require (
	github.com/gin-gonic/gin v1.9.1
	github.com/stretchr/testify v1.8.4
	go.uber.org/zap v1.26.0
)

require (
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
)
`
	err := os.WriteFile(goModPath, []byte(goModContent), 0644)
	require.NoError(t, err)

	config := &CheckerConfig{
		Database:   DefaultDatabaseConfig(),
		ModulePath: tmpDir,
	}

	logger := zaptest.NewLogger(t)
	checker, err := NewVulnerabilityChecker(config, logger)
	require.NoError(t, err)

	// Test the fallback method directly
	deps, err := checker.parseGoModFile()
	require.NoError(t, err)

	// Should have all dependencies (both direct and indirect)
	assert.GreaterOrEqual(t, len(deps), 3)
	assert.Contains(t, deps, "github.com/gin-gonic/gin")
	assert.Contains(t, deps, "github.com/stretchr/testify")
	assert.Contains(t, deps, "go.uber.org/zap")
	assert.Contains(t, deps, "github.com/davecgh/go-spew")
	assert.Contains(t, deps, "github.com/pmezard/go-difflib")
	
	// Verify versions
	assert.Equal(t, "v1.9.1", deps["github.com/gin-gonic/gin"])
	assert.Equal(t, "v1.8.4", deps["github.com/stretchr/testify"])
	assert.Equal(t, "v1.26.0", deps["go.uber.org/zap"])
	assert.Equal(t, "v1.1.1", deps["github.com/davecgh/go-spew"])
	assert.Equal(t, "v1.0.0", deps["github.com/pmezard/go-difflib"])
}

func TestVulnerabilityChecker_ConvertToFinding(t *testing.T) {
	logger := zaptest.NewLogger(t)
	checker, err := NewVulnerabilityChecker(nil, logger)
	require.NoError(t, err)

	vuln := &Vulnerability{
		ID:      "GO-2024-0001",
		Summary: "Test vulnerability",
		Details: "This is a test vulnerability for testing purposes",
		Aliases: []string{"CVE-2024-0001"},
		References: []Reference{
			{Type: "WEB", URL: "https://example.com/vuln"},
		},
		Severity: []SeverityInfo{
			{Type: "CVSS_V3", Score: "7.5"},
		},
		Affected: []AffectedPackage{
			{
				Package: PackageInfo{
					Name:      "github.com/example/package",
					Ecosystem: "Go",
				},
				Ranges: []VersionRange{
					{
						Type: "SEMVER",
						Events: []VersionEvent{
							{Fixed: "v1.2.3"},
						},
					},
				},
			},
		},
	}

	finding := checker.convertToFinding("github.com/example/package", "v1.2.0", vuln)

	assert.Equal(t, "GO-2024-0001", finding.VulnerabilityID)
	assert.Equal(t, "github.com/example/package", finding.PackageName)
	assert.Equal(t, "v1.2.0", finding.InstalledVersion)
	assert.Equal(t, "v1.2.3", finding.FixedVersion)
	assert.Equal(t, "Test vulnerability", finding.Summary)
	assert.Contains(t, finding.References, "https://example.com/vuln")
	assert.Contains(t, finding.Aliases, "CVE-2024-0001")
}

func TestVulnerabilityChecker_ExtractSeverity(t *testing.T) {
	logger := zaptest.NewLogger(t)
	checker, err := NewVulnerabilityChecker(nil, logger)
	require.NoError(t, err)

	tests := []struct {
		name         string
		vuln         *Vulnerability
		wantSeverity string
		minCVSS      float64
		maxCVSS      float64
	}{
		{
			name: "critical severity",
			vuln: &Vulnerability{
				Severity: []SeverityInfo{
					{Type: "CVSS_V3", Score: "9.8"},
				},
			},
			wantSeverity: "critical",
			minCVSS:      9.0,
			maxCVSS:      10.0,
		},
		{
			name: "high severity",
			vuln: &Vulnerability{
				Severity: []SeverityInfo{
					{Type: "CVSS_V3", Score: "7.5"},
				},
			},
			wantSeverity: "high",
			minCVSS:      7.0,
			maxCVSS:      8.9,
		},
		{
			name: "medium severity",
			vuln: &Vulnerability{
				Severity: []SeverityInfo{
					{Type: "CVSS_V3", Score: "5.0"},
				},
			},
			wantSeverity: "medium",
			minCVSS:      4.0,
			maxCVSS:      6.9,
		},
		{
			name: "low severity",
			vuln: &Vulnerability{
				Severity: []SeverityInfo{
					{Type: "CVSS_V3", Score: "3.0"},
				},
			},
			wantSeverity: "low",
			minCVSS:      0.1,
			maxCVSS:      3.9,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			severity, cvss := checker.extractSeverity(tt.vuln)
			assert.Equal(t, tt.wantSeverity, severity)
			assert.GreaterOrEqual(t, cvss, tt.minCVSS)
			assert.LessOrEqual(t, cvss, tt.maxCVSS)
		})
	}
}

func TestVulnerabilityChecker_ParseCVSS(t *testing.T) {
	logger := zaptest.NewLogger(t)
	checker, err := NewVulnerabilityChecker(nil, logger)
	require.NoError(t, err)

	tests := []struct {
		name     string
		scoreStr string
		minScore float64
		maxScore float64
	}{
		{
			name:     "numeric score",
			scoreStr: "7.5",
			minScore: 7.5,
			maxScore: 7.5,
		},
		{
			name:     "CVSS vector with high impact",
			scoreStr: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
			minScore: 7.0,
			maxScore: 10.0,
		},
		{
			name:     "empty score",
			scoreStr: "",
			minScore: 0.0,
			maxScore: 10.0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			score := checker.parseCVSS(tt.scoreStr)
			assert.GreaterOrEqual(t, score, tt.minScore)
			assert.LessOrEqual(t, score, tt.maxScore)
		})
	}
}

func TestVulnerabilityChecker_ShouldFail(t *testing.T) {
	tests := []struct {
		name       string
		config     *CheckerConfig
		result     *CheckResult
		shouldFail bool
	}{
		{
			name: "fail on critical",
			config: &CheckerConfig{
				FailOnCritical: true,
				FailOnHigh:     false,
				FailOnMedium:   false,
			},
			result: &CheckResult{
				Summary: CheckSummary{
					CriticalCount: 1,
				},
			},
			shouldFail: true,
		},
		{
			name: "fail on high",
			config: &CheckerConfig{
				FailOnCritical: false,
				FailOnHigh:     true,
				FailOnMedium:   false,
			},
			result: &CheckResult{
				Summary: CheckSummary{
					HighCount: 1,
				},
			},
			shouldFail: true,
		},
		{
			name: "fail on medium",
			config: &CheckerConfig{
				FailOnCritical: false,
				FailOnHigh:     false,
				FailOnMedium:   true,
			},
			result: &CheckResult{
				Summary: CheckSummary{
					MediumCount: 1,
				},
			},
			shouldFail: true,
		},
		{
			name: "no vulnerabilities",
			config: &CheckerConfig{
				FailOnCritical: true,
				FailOnHigh:     true,
				FailOnMedium:   true,
			},
			result: &CheckResult{
				Summary: CheckSummary{},
			},
			shouldFail: false,
		},
		{
			name: "low severity only",
			config: &CheckerConfig{
				FailOnCritical: true,
				FailOnHigh:     true,
				FailOnMedium:   true,
			},
			result: &CheckResult{
				Summary: CheckSummary{
					LowCount: 5,
				},
			},
			shouldFail: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			logger := zaptest.NewLogger(t)
			checker, err := NewVulnerabilityChecker(tt.config, logger)
			require.NoError(t, err)

			shouldFail := checker.ShouldFail(tt.result)
			assert.Equal(t, tt.shouldFail, shouldFail)
		})
	}
}

func TestVulnerabilityChecker_SaveReport(t *testing.T) {
	tmpDir := t.TempDir()
	reportPath := filepath.Join(tmpDir, "reports", "vuln-report.json")

	config := &CheckerConfig{
		Database:   DefaultDatabaseConfig(),
		ReportPath: reportPath,
	}

	logger := zaptest.NewLogger(t)
	checker, err := NewVulnerabilityChecker(config, logger)
	require.NoError(t, err)

	result := &CheckResult{
		Timestamp:  time.Now(),
		Duration:   1 * time.Second,
		ModulePath: "example.com/test",
		Summary: CheckSummary{
			TotalDependencies:    10,
			VulnerableCount:      2,
			TotalVulnerabilities: 3,
			CriticalCount:        1,
			HighCount:            1,
			MediumCount:          1,
		},
		Vulnerabilities: []VulnerabilityFinding{
			{
				VulnerabilityID:  "GO-2024-0001",
				PackageName:      "github.com/example/vuln",
				InstalledVersion: "v1.0.0",
				FixedVersion:     "v1.1.0",
				Severity:         "high",
				CVSS:             7.5,
				Summary:          "Test vulnerability",
			},
		},
	}

	err = checker.saveReport(result)
	require.NoError(t, err)

	// Verify report file exists
	_, err = os.Stat(reportPath)
	assert.NoError(t, err)

	// Verify report content
	data, err := os.ReadFile(reportPath)
	require.NoError(t, err)
	assert.Contains(t, string(data), "GO-2024-0001")
	assert.Contains(t, string(data), "github.com/example/vuln")
}

func TestCheckResult_Summary(t *testing.T) {
	result := &CheckResult{
		Summary: CheckSummary{
			TotalDependencies:    100,
			VulnerableCount:      5,
			TotalVulnerabilities: 10,
			CriticalCount:        2,
			HighCount:            3,
			MediumCount:          3,
			LowCount:             2,
		},
	}

	assert.Equal(t, 100, result.Summary.TotalDependencies)
	assert.Equal(t, 5, result.Summary.VulnerableCount)
	assert.Equal(t, 10, result.Summary.TotalVulnerabilities)
	assert.Equal(t, 2, result.Summary.CriticalCount)
	assert.Equal(t, 3, result.Summary.HighCount)
	assert.Equal(t, 3, result.Summary.MediumCount)
	assert.Equal(t, 2, result.Summary.LowCount)
}

func TestVulnerabilityFinding_Fields(t *testing.T) {
	finding := VulnerabilityFinding{
		VulnerabilityID:  "GO-2024-0001",
		PackageName:      "github.com/example/package",
		InstalledVersion: "v1.0.0",
		FixedVersion:     "v1.1.0",
		Severity:         "high",
		CVSS:             7.5,
		Summary:          "Test vulnerability",
		Details:          "Detailed description",
		References:       []string{"https://example.com/vuln"},
		Aliases:          []string{"CVE-2024-0001"},
	}

	assert.Equal(t, "GO-2024-0001", finding.VulnerabilityID)
	assert.Equal(t, "github.com/example/package", finding.PackageName)
	assert.Equal(t, "v1.0.0", finding.InstalledVersion)
	assert.Equal(t, "v1.1.0", finding.FixedVersion)
	assert.Equal(t, "high", finding.Severity)
	assert.Equal(t, 7.5, finding.CVSS)
	assert.Equal(t, "Test vulnerability", finding.Summary)
	assert.Equal(t, "Detailed description", finding.Details)
	assert.Len(t, finding.References, 1)
	assert.Len(t, finding.Aliases, 1)
}

// TestVulnerabilityChecker_Check_Integration tests the full check workflow
// This is a basic integration test that doesn't make real API calls
func TestVulnerabilityChecker_Check_Integration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	// This test would need a real go.mod file and network access
	// For now, we skip it in regular test runs
	t.Skip("Integration test requires network access and real go.mod")
}

func TestVulnerabilityReport_Structure(t *testing.T) {
	report := &VulnerabilityReport{
		GeneratedAt:   time.Now(),
		ModulePath:    "example.com/test",
		CheckDuration: 5 * time.Second,
		Summary: CheckSummary{
			TotalDependencies:    50,
			VulnerableCount:      2,
			TotalVulnerabilities: 3,
			CriticalCount:        1,
			HighCount:            1,
			MediumCount:          1,
		},
		Vulnerabilities: []VulnerabilityFinding{
			{
				VulnerabilityID: "GO-2024-0001",
				PackageName:     "github.com/example/vuln",
				Severity:        "high",
			},
		},
	}

	assert.NotZero(t, report.GeneratedAt)
	assert.Equal(t, "example.com/test", report.ModulePath)
	assert.Equal(t, 5*time.Second, report.CheckDuration)
	assert.Equal(t, 50, report.Summary.TotalDependencies)
	assert.Len(t, report.Vulnerabilities, 1)
}

func TestVulnerabilityChecker_ContextCancellation(t *testing.T) {
	tmpDir := t.TempDir()
	goModPath := filepath.Join(tmpDir, "go.mod")

	goModContent := `module example.com/test

go 1.23

require (
	github.com/gin-gonic/gin v1.9.1
)
`
	err := os.WriteFile(goModPath, []byte(goModContent), 0644)
	require.NoError(t, err)

	config := &CheckerConfig{
		Database:   DefaultDatabaseConfig(),
		ModulePath: tmpDir,
		Timeout:    1 * time.Nanosecond, // Very short timeout
	}

	logger := zaptest.NewLogger(t)
	checker, err := NewVulnerabilityChecker(config, logger)
	require.NoError(t, err)

	ctx := context.Background()
	result, err := checker.Check(ctx)

	// Should handle timeout gracefully
	assert.NotNil(t, result)
	// Error might or might not occur depending on timing
	if err != nil {
		assert.Contains(t, err.Error(), "context deadline exceeded")
	}
}
