// Copyright Â© 2025 jackelyj <dreamerlyj@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

package vulnerability

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestNewOSVDatabase(t *testing.T) {
	tests := []struct {
		name    string
		config  *DatabaseConfig
		wantErr bool
	}{
		{
			name:    "with default config",
			config:  nil,
			wantErr: false,
		},
		{
			name:    "with custom config",
			config:  DefaultDatabaseConfig(),
			wantErr: false,
		},
		{
			name: "with custom API URL",
			config: &DatabaseConfig{
				APIURL:  "https://custom.api.example.com",
				Timeout: 10 * time.Second,
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			db, err := NewOSVDatabase(tt.config)

			if tt.wantErr {
				assert.Error(t, err)
				assert.Nil(t, db)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, db)
				assert.NotNil(t, db.httpClient)
			}
		})
	}
}

func TestDefaultDatabaseConfig(t *testing.T) {
	config := DefaultDatabaseConfig()

	assert.NotNil(t, config)
	assert.Equal(t, DefaultOSVAPIURL, config.APIURL)
	assert.Equal(t, DefaultTimeout, config.Timeout)
	assert.Equal(t, 24*time.Hour, config.UpdateInterval)
}

func TestOSVDatabase_Query(t *testing.T) {
	// Create a test server
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		assert.Equal(t, "/v1/query", r.URL.Path)
		assert.Equal(t, "POST", r.Method)
		assert.Equal(t, "application/json", r.Header.Get("Content-Type"))

		// Parse request
		var req QueryRequest
		err := json.NewDecoder(r.Body).Decode(&req)
		assert.NoError(t, err)

		// Return mock response
		response := QueryResponse{
			Vulns: []Vulnerability{
				{
					ID:      "GO-2024-0001",
					Summary: "Test vulnerability",
					Details: "This is a test",
					Severity: []SeverityInfo{
						{Type: "CVSS_V3", Score: "7.5"},
					},
				},
			},
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
	}))
	defer server.Close()

	config := &DatabaseConfig{
		APIURL:  server.URL,
		Timeout: 5 * time.Second,
	}

	db, err := NewOSVDatabase(config)
	require.NoError(t, err)

	ctx := context.Background()
	req := &QueryRequest{
		Package: &PackageInfo{
			Name:      "github.com/example/package",
			Ecosystem: "Go",
		},
		Version: "v1.0.0",
	}

	resp, err := db.Query(ctx, req)
	require.NoError(t, err)
	assert.NotNil(t, resp)
	assert.Len(t, resp.Vulns, 1)
	assert.Equal(t, "GO-2024-0001", resp.Vulns[0].ID)
	assert.Equal(t, "Test vulnerability", resp.Vulns[0].Summary)
}

func TestOSVDatabase_Query_Errors(t *testing.T) {
	tests := []struct {
		name        string
		req         *QueryRequest
		serverCode  int
		serverResp  string
		wantErr     bool
		errContains string
	}{
		{
			name:        "nil request",
			req:         nil,
			wantErr:     true,
			errContains: "cannot be nil",
		},
		{
			name: "server error",
			req: &QueryRequest{
				Package: &PackageInfo{
					Name:      "test",
					Ecosystem: "Go",
				},
			},
			serverCode:  http.StatusInternalServerError,
			serverResp:  "Internal Server Error",
			wantErr:     true,
			errContains: "500",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.serverCode != 0 {
				server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
					w.WriteHeader(tt.serverCode)
					w.Write([]byte(tt.serverResp))
				}))
				defer server.Close()

				config := &DatabaseConfig{
					APIURL:  server.URL,
					Timeout: 5 * time.Second,
				}

				db, err := NewOSVDatabase(config)
				require.NoError(t, err)

				ctx := context.Background()
				_, err = db.Query(ctx, tt.req)

				if tt.wantErr {
					assert.Error(t, err)
					if tt.errContains != "" {
						assert.Contains(t, err.Error(), tt.errContains)
					}
				}
			} else {
				config := DefaultDatabaseConfig()
				db, err := NewOSVDatabase(config)
				require.NoError(t, err)

				ctx := context.Background()
				_, err = db.Query(ctx, tt.req)

				if tt.wantErr {
					assert.Error(t, err)
					if tt.errContains != "" {
						assert.Contains(t, err.Error(), tt.errContains)
					}
				}
			}
		})
	}
}

func TestOSVDatabase_BatchQuery(t *testing.T) {
	// Create a test server
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		assert.Equal(t, "/v1/querybatch", r.URL.Path)
		assert.Equal(t, "POST", r.Method)

		// Parse request
		var req BatchQueryRequest
		err := json.NewDecoder(r.Body).Decode(&req)
		assert.NoError(t, err)

		// Return mock response
		response := BatchQueryResponse{
			Results: []QueryResponse{
				{
					Vulns: []Vulnerability{
						{
							ID:      "GO-2024-0001",
							Summary: "Test vulnerability 1",
						},
					},
				},
				{
					Vulns: []Vulnerability{},
				},
			},
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
	}))
	defer server.Close()

	config := &DatabaseConfig{
		APIURL:  server.URL,
		Timeout: 5 * time.Second,
	}

	db, err := NewOSVDatabase(config)
	require.NoError(t, err)

	ctx := context.Background()
	queries := []QueryRequest{
		{
			Package: &PackageInfo{
				Name:      "github.com/example/package1",
				Ecosystem: "Go",
			},
			Version: "v1.0.0",
		},
		{
			Package: &PackageInfo{
				Name:      "github.com/example/package2",
				Ecosystem: "Go",
			},
			Version: "v2.0.0",
		},
	}

	resp, err := db.BatchQuery(ctx, queries)
	require.NoError(t, err)
	assert.NotNil(t, resp)
	assert.Len(t, resp.Results, 2)
	assert.Len(t, resp.Results[0].Vulns, 1)
	assert.Len(t, resp.Results[1].Vulns, 0)
}

func TestOSVDatabase_BatchQuery_EmptyQueries(t *testing.T) {
	config := DefaultDatabaseConfig()
	db, err := NewOSVDatabase(config)
	require.NoError(t, err)

	ctx := context.Background()
	resp, err := db.BatchQuery(ctx, []QueryRequest{})

	require.NoError(t, err)
	assert.NotNil(t, resp)
	assert.Empty(t, resp.Results)
}

func TestOSVDatabase_GetVulnerability(t *testing.T) {
	// Create a test server
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		assert.Equal(t, "GET", r.Method)
		assert.Contains(t, r.URL.Path, "/v1/vulns/")

		vulnID := r.URL.Path[len("/v1/vulns/"):]
		if vulnID == "GO-2024-0001" {
			response := Vulnerability{
				ID:      "GO-2024-0001",
				Summary: "Test vulnerability",
				Details: "This is a test vulnerability",
				Severity: []SeverityInfo{
					{Type: "CVSS_V3", Score: "7.5"},
				},
			}

			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(response)
		} else {
			w.WriteHeader(http.StatusNotFound)
		}
	}))
	defer server.Close()

	config := &DatabaseConfig{
		APIURL:  server.URL,
		Timeout: 5 * time.Second,
	}

	db, err := NewOSVDatabase(config)
	require.NoError(t, err)

	ctx := context.Background()

	// Test successful retrieval
	vuln, err := db.GetVulnerability(ctx, "GO-2024-0001")
	require.NoError(t, err)
	assert.NotNil(t, vuln)
	assert.Equal(t, "GO-2024-0001", vuln.ID)
	assert.Equal(t, "Test vulnerability", vuln.Summary)

	// Test not found
	_, err = db.GetVulnerability(ctx, "GO-9999-9999")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "not found")

	// Test empty ID
	_, err = db.GetVulnerability(ctx, "")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "cannot be empty")
}

func TestOSVDatabase_UpdateDatabase(t *testing.T) {
	config := DefaultDatabaseConfig()
	db, err := NewOSVDatabase(config)
	require.NoError(t, err)

	ctx := context.Background()

	// First update should succeed
	err = db.UpdateDatabase(ctx)
	assert.NoError(t, err)

	// Immediate second update should be skipped
	err = db.UpdateDatabase(ctx)
	assert.NoError(t, err)
}

func TestOSVDatabase_NeedsUpdate(t *testing.T) {
	config := DefaultDatabaseConfig()
	db, err := NewOSVDatabase(config)
	require.NoError(t, err)

	// Just created, should not need update
	needsUpdate := db.NeedsUpdate(24 * time.Hour)
	assert.False(t, needsUpdate)

	// Set last update to old time
	db.lastUpdate = time.Now().Add(-25 * time.Hour)
	needsUpdate = db.NeedsUpdate(24 * time.Hour)
	assert.True(t, needsUpdate)
}

func TestOSVDatabase_GetLastUpdateTime(t *testing.T) {
	config := DefaultDatabaseConfig()
	db, err := NewOSVDatabase(config)
	require.NoError(t, err)

	lastUpdate := db.GetLastUpdateTime()
	assert.True(t, time.Since(lastUpdate) < 1*time.Second)
}

func TestPackageInfo_Structure(t *testing.T) {
	pkg := PackageInfo{
		Name:      "github.com/example/package",
		Ecosystem: "Go",
	}

	assert.Equal(t, "github.com/example/package", pkg.Name)
	assert.Equal(t, "Go", pkg.Ecosystem)
}

func TestVulnerability_Structure(t *testing.T) {
	vuln := Vulnerability{
		ID:        "GO-2024-0001",
		Summary:   "Test vulnerability",
		Details:   "Detailed description",
		Aliases:   []string{"CVE-2024-0001", "GHSA-xxxx-yyyy-zzzz"},
		Modified:  "2024-01-01T00:00:00Z",
		Published: "2024-01-01T00:00:00Z",
		References: []Reference{
			{Type: "WEB", URL: "https://example.com"},
		},
		Severity: []SeverityInfo{
			{Type: "CVSS_V3", Score: "7.5"},
		},
		Affected: []AffectedPackage{
			{
				Package: PackageInfo{
					Name:      "github.com/example/package",
					Ecosystem: "Go",
				},
			},
		},
	}

	assert.Equal(t, "GO-2024-0001", vuln.ID)
	assert.Equal(t, "Test vulnerability", vuln.Summary)
	assert.Len(t, vuln.Aliases, 2)
	assert.Len(t, vuln.References, 1)
	assert.Len(t, vuln.Severity, 1)
	assert.Len(t, vuln.Affected, 1)
}

func TestVersionRange_Structure(t *testing.T) {
	vr := VersionRange{
		Type: "SEMVER",
		Events: []VersionEvent{
			{Introduced: "v1.0.0"},
			{Fixed: "v1.2.0"},
		},
	}

	assert.Equal(t, "SEMVER", vr.Type)
	assert.Len(t, vr.Events, 2)
	assert.Equal(t, "v1.0.0", vr.Events[0].Introduced)
	assert.Equal(t, "v1.2.0", vr.Events[1].Fixed)
}

func TestOSVDatabase_ContextCancellation(t *testing.T) {
	// Create a slow test server
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		time.Sleep(2 * time.Second)
		w.WriteHeader(http.StatusOK)
	}))
	defer server.Close()

	config := &DatabaseConfig{
		APIURL:  server.URL,
		Timeout: 5 * time.Second,
	}

	db, err := NewOSVDatabase(config)
	require.NoError(t, err)

	// Create a context with short timeout
	ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
	defer cancel()

	req := &QueryRequest{
		Package: &PackageInfo{
			Name:      "test",
			Ecosystem: "Go",
		},
	}

	_, err = db.Query(ctx, req)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "context deadline exceeded")
}
