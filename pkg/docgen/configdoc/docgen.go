// Copyright Â© 2025 jackelyj <dreamerlyj@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

package configdoc

import (
	"bytes"
	"fmt"
	"reflect"
	"sort"
	"strings"
	"time"

	"github.com/innovationmech/swit/pkg/messaging"
	"github.com/innovationmech/swit/pkg/messaging/kafka"
	"github.com/innovationmech/swit/pkg/messaging/rabbitmq"
	"github.com/innovationmech/swit/pkg/server"
)

// Target describes a documentation generation target
type Target struct {
	// Title is the section title (e.g., "ServerConfig")
	Title string
	// Type is the root struct type to document
	Type reflect.Type
	// DefaultValue holds an optional value instance used to capture default values
	// from SetDefaults or constructor functions. Can be nil.
	DefaultValue reflect.Value
	// RootKey is the top-level YAML key path prefix (optional)
	RootKey string
}

// Generate renders Markdown documentation for the provided targets.
func Generate(targets []Target) (string, error) {
	var buf bytes.Buffer

	// Header
	buf.WriteString("<!-- Generated by swit docgen; DO NOT EDIT MANUALLY -->\n\n")
	buf.WriteString("## Configuration Reference (generated)\n\n")

	for i, t := range targets {
		if t.Type.Kind() == reflect.Pointer {
			t.Type = t.Type.Elem()
		}
		if t.Type.Kind() != reflect.Struct {
			return "", fmt.Errorf("target %d (%s) is not a struct type", i, t.Title)
		}
		sectionTitle := t.Title
		if sectionTitle == "" {
			sectionTitle = t.Type.Name()
		}
		buf.WriteString(fmt.Sprintf("## %s\n\n", sectionTitle))
		walkStruct(&buf, t.Type, t.DefaultValue, t.RootKey, 2)
		buf.WriteString("\n")
	}

	return buf.String(), nil
}

// walkStruct writes a section for the given struct type (and nested structs).
func walkStruct(buf *bytes.Buffer, t reflect.Type, dv reflect.Value, keyPrefix string, headingLevel int) {
	// Normalize default value
	if dv.IsValid() && dv.Kind() == reflect.Pointer {
		dv = dv.Elem()
	}

	// Print table header
	buf.WriteString("| Key | Type | Required | Default | Tags |\n")
	buf.WriteString("|-----|------|----------|---------|------|\n")

	// Sort fields by YAML key for stable output
	fields := visibleFields(t)
	sort.Slice(fields, func(i, j int) bool { return fields[i].Name < fields[j].Name })

	for _, f := range fields {
		yamlKey := parseKey(f.Tag.Get("yaml"))
		if yamlKey == "-" {
			continue
		}
		if yamlKey == "" {
			yamlKey = toSnakeCase(f.Name)
		}
		fullKey := joinKey(keyPrefix, yamlKey)

		// Type and Required
		typeStr := displayType(f.Type)
		required := isRequiredFromValidate(f.Tag.Get("validate"))

		// Default value
		def := ""
		if tagDefault := f.Tag.Get("default"); tagDefault != "" {
			def = tagDefault
		} else if dv.IsValid() {
			// Read default from value instance if present
			fv := fieldValueByIndex(dv, f.Index)
			if fv.IsValid() && !isZeroValue(fv) {
				def = formatValue(fv)
			}
		}

		// Tags summary (yaml/json/validate)
		tagSummary := summarizeTags(f.Tag)

		buf.WriteString(fmt.Sprintf("| `%s` | `%s` | %s | %s | %s |\n",
			fullKey,
			typeStr,
			yesNo(required),
			escapePipes(def),
			escapePipes(tagSummary),
		))

		// Recurse into nested structs (non-time types) and non-scalar composites for separate sections
		nested := f.Type
		if nested.Kind() == reflect.Pointer {
			nested = nested.Elem()
		}
		if nested.Kind() == reflect.Struct && nested.PkgPath() != "time" {
			var nestedDV reflect.Value
			if dv.IsValid() {
				v := fieldValueByIndex(dv, f.Index)
				if v.IsValid() && v.Kind() == reflect.Pointer {
					v = v.Elem()
				}
				nestedDV = v
			}
			// Add a small separation and subheading for nested struct
			buf.WriteString("\n")
			buf.WriteString(fmt.Sprintf("### %s\n\n", fullKey))
			walkStruct(buf, nested, nestedDV, fullKey, headingLevel+1)
		}
	}
}

func visibleFields(t reflect.Type) []reflect.StructField {
	var out []reflect.StructField
	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)
		if f.PkgPath != "" { // unexported
			continue
		}
		out = append(out, f)
	}
	return out
}

func parseKey(tag string) string {
	if tag == "" {
		return ""
	}
	parts := strings.Split(tag, ",")
	return strings.TrimSpace(parts[0])
}

func joinKey(prefix, key string) string {
	if prefix == "" {
		return key
	}
	return prefix + "." + key
}

func yesNo(b bool) string {
	if b {
		return "**Yes**"
	}
	return "No"
}

func isRequiredFromValidate(tag string) bool {
	if tag == "" {
		return false
	}
	// Simple heuristics: required, notblank, min=1 for slices
	parts := strings.Split(tag, ",")
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if p == "required" || p == "notblank" || strings.HasPrefix(p, "min=") {
			return true
		}
	}
	return false
}

func displayType(t reflect.Type) string {
	// Deref pointer
	if t.Kind() == reflect.Pointer {
		t = t.Elem()
	}
	switch t.Kind() {
	case reflect.Bool:
		return "bool"
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		if t.PkgPath() == "time" && t.Name() == "Duration" {
			return "time.Duration"
		}
		return "int"
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return "uint"
	case reflect.Float32, reflect.Float64:
		return "float"
	case reflect.String:
		return "string"
	case reflect.Slice:
		return "[]" + displayType(t.Elem())
	case reflect.Map:
		return "map[" + displayType(t.Key()) + "]" + displayType(t.Elem())
	case reflect.Struct:
		if t.PkgPath() == "time" && t.Name() == "Time" {
			return "time.Time"
		}
		if t.PkgPath() == "github.com/innovationmech/swit/pkg/messaging" && t.Name() == "Duration" {
			return "messaging.Duration"
		}
		return t.Name()
	default:
		return t.String()
	}
}

func fieldValueByIndex(v reflect.Value, index []int) reflect.Value {
	if !v.IsValid() {
		return reflect.Value{}
	}
	for _, i := range index {
		if v.Kind() == reflect.Pointer {
			if v.IsNil() {
				return reflect.Value{}
			}
			v = v.Elem()
		}
		if v.Kind() != reflect.Struct {
			return reflect.Value{}
		}
		v = v.Field(i)
	}
	return v
}

func isZeroValue(v reflect.Value) bool {
	if !v.IsValid() {
		return true
	}
	switch v.Kind() {
	case reflect.Bool:
		return !v.Bool()
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return v.Int() == 0
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return v.Uint() == 0
	case reflect.Float32, reflect.Float64:
		return v.Float() == 0
	case reflect.String:
		return v.String() == ""
	case reflect.Slice, reflect.Map:
		return v.Len() == 0
	case reflect.Pointer, reflect.Interface:
		return v.IsNil()
	case reflect.Struct:
		// Consider struct zero if all fields are zero
		for i := 0; i < v.NumField(); i++ {
			if !isZeroValue(v.Field(i)) {
				return false
			}
		}
		return true
	default:
		return v.IsZero()
	}
}

func formatValue(v reflect.Value) string {
	if !v.IsValid() {
		return ""
	}
	if v.Kind() == reflect.Pointer {
		if v.IsNil() {
			return ""
		}
		v = v.Elem()
	}
	switch v.Kind() {
	case reflect.Bool:
		if v.Bool() {
			return "true"
		}
		return "false"
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		// time.Duration pretty-print
		if v.Type().PkgPath() == "time" && v.Type().Name() == "Duration" {
			return time.Duration(v.Int()).String()
		}
		return fmt.Sprintf("%d", v.Int())
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return fmt.Sprintf("%d", v.Uint())
	case reflect.Float32, reflect.Float64:
		return fmt.Sprintf("%g", v.Float())
	case reflect.String:
		s := v.String()
		if s == "" {
			return "\"\""
		}
		// Quote strings to make it clear
		return fmt.Sprintf("\"%s\"", s)
	case reflect.Slice:
		if v.Len() == 0 {
			return "[]"
		}
		// Show length to avoid overly long defaults
		return fmt.Sprintf("len=%d", v.Len())
	case reflect.Map:
		if v.Len() == 0 {
			return "{}"
		}
		return fmt.Sprintf("len=%d", v.Len())
	case reflect.Struct:
		// Do not inline complex structs as defaults
		return "(struct)"
	default:
		return ""
	}
}

func summarizeTags(tag reflect.StructTag) string {
	var parts []string
	if y := parseKey(tag.Get("yaml")); y != "" {
		parts = append(parts, "yaml:"+y)
	}
	if j := parseKey(tag.Get("json")); j != "" {
		parts = append(parts, "json:"+j)
	}
	if v := tag.Get("validate"); v != "" {
		parts = append(parts, "validate:"+v)
	}
	if d := tag.Get("default"); d != "" {
		parts = append(parts, "default:"+d)
	}
	return strings.Join(parts, ", ")
}

func toSnakeCase(s string) string {
	var out []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			out = append(out, '_', r+('a'-'A'))
		} else {
			out = append(out, toLower(r))
		}
	}
	return string(out)
}

func toLower(r rune) rune {
	if r >= 'A' && r <= 'Z' {
		return r + ('a' - 'A')
	}
	return r
}

func escapePipes(s string) string {
	s = strings.ReplaceAll(s, "|", "\\|")
	return s
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// DefaultTargets returns a curated list of configuration roots to document.
func DefaultTargets() []Target {
	// ServerConfig with defaults
	sc := server.NewServerConfig()
	sc.SetDefaults()

	// Messaging broker config defaults (library-level)
	var bc messaging.BrokerConfig
	bc.SetDefaults()

	// Adapter defaults
	kc := kafka.DefaultConfig()
	rc := rabbitmq.DefaultConfig()

	return []Target{
		{Title: "ServerConfig", Type: reflect.TypeOf(*sc), DefaultValue: reflect.ValueOf(sc).Elem(), RootKey: ""},
		{Title: "Messaging BrokerConfig", Type: reflect.TypeOf(bc), DefaultValue: reflect.ValueOf(bc), RootKey: "messaging.brokers.<name>"},
		{Title: "Kafka Adapter (Extra)", Type: reflect.TypeOf(*kc), DefaultValue: reflect.ValueOf(kc).Elem(), RootKey: "messaging.brokers.<name>.extra.kafka"},
		{Title: "RabbitMQ Adapter (Extra)", Type: reflect.TypeOf(*rc), DefaultValue: reflect.ValueOf(rc).Elem(), RootKey: "messaging.brokers.<name>.extra.rabbitmq"},
	}
}
